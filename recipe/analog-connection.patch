diff --git a/include/circt/Dialect/Calyx/CalyxLoweringUtils.h b/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
index 48309c42b..6887610f5 100644
--- a/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
+++ b/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
@@ -129,7 +129,7 @@ public:
   virtual Value getConditionValue() = 0;
 
   // Returns the number of iterations the loop will conduct if known.
-  virtual Optional<uint64_t> getBound() = 0;
+  virtual std::optional<uint64_t> getBound() = 0;
 
   // Returns the location of the loop interface.
   virtual Location getLoc() = 0;
diff --git a/include/circt/Dialect/Comb/Combinational.td b/include/circt/Dialect/Comb/Combinational.td
index b4890eef2..61487205a 100644
--- a/include/circt/Dialect/Comb/Combinational.td
+++ b/include/circt/Dialect/Comb/Combinational.td
@@ -228,7 +228,7 @@ def ConcatOp : CombOp<"concat", [InferTypeOpInterface, Pure]> {
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/include/circt/Dialect/FIRRTL/CHIRRTL.td b/include/circt/Dialect/FIRRTL/CHIRRTL.td
index 875296d91..961f17bd8 100644
--- a/include/circt/Dialect/FIRRTL/CHIRRTL.td
+++ b/include/circt/Dialect/FIRRTL/CHIRRTL.td
@@ -181,7 +181,7 @@ def MemoryPortOp : CHIRRTLOp<"memoryport", [InferTypeOpInterface,
 
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
@@ -237,7 +237,7 @@ def MemoryDebugPortOp : CHIRRTLOp<"debugport", [InferTypeOpInterface,
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLExpressions.td b/include/circt/Dialect/FIRRTL/FIRRTLExpressions.td
index 733f160fc..c3e12a264 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLExpressions.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLExpressions.td
@@ -34,7 +34,7 @@ class FIRRTLExprOp<string mnemonic, list<Trait> traits = []> :
     /// Infer the return type of this operation.
     static FIRRTLType inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc);
+                                      std::optional<Location> loc);
   }];
 
   // The operation-specific validator for a parsed list of operands and
@@ -61,7 +61,7 @@ class FIRRTLExprOp<string mnemonic, list<Trait> traits = []> :
     /// `InferTypeOpInterface`. We simply forward to a narrower
     /// operation-specific implementation which is sufficient for FIRRTL ops.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
@@ -354,13 +354,13 @@ class BinaryPrimOp<string mnemonic, Type lhsType, Type rhsType, Type resultType,
   let inferTypeDecl = !if(!empty(inferType), [{
     /// Infer the return type of this binary operation.
     static FIRRTLType inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                            Optional<Location> loc);
+                                            std::optional<Location> loc);
     }], "") # !subst("$_infer", !if(!empty(inferType), "inferBinaryReturnType",
       inferType), [{
     /// Infer the return type of this operation.
     static FIRRTLType inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
       return $_infer(operands[0].getType().cast<FIRRTLType>(),
                      operands[1].getType().cast<FIRRTLType>(),
                      loc);
@@ -459,13 +459,13 @@ class UnaryPrimOp<string mnemonic, Type srcType, Type resultType,
   let inferTypeDecl = !if(!empty(inferType), [{
     /// Infer the return type of this unary operation.
     static FIRRTLType inferUnaryReturnType(FIRRTLType arg,
-                                           Optional<Location> loc);
+                                           std::optional<Location> loc);
     }], "") # !subst("$_infer", !if(!empty(inferType), "inferUnaryReturnType",
       inferType), [{
     /// Infer the return type of this operation.
     static FIRRTLType inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
       return $_infer(operands[0].getType().cast<FIRRTLType>(), loc);
     }
   }]);
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLOps.h b/include/circt/Dialect/FIRRTL/FIRRTLOps.h
index e843f6503..5d98b5d7d 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLOps.h
+++ b/include/circt/Dialect/FIRRTL/FIRRTLOps.h
@@ -133,21 +133,21 @@ LogicalResult verifySameOperandsIntTypeKind(Operation *op);
 
 // Type inference adaptor for FIRRTL operations.
 LogicalResult inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results,
     llvm::function_ref<FIRRTLType(ValueRange, ArrayRef<NamedAttribute>,
-                                  Optional<Location>)>
+                                  std::optional<Location>)>
         callback);
 
 // Common type inference functions.
 FIRRTLType inferAddSubResult(FIRRTLType lhs, FIRRTLType rhs,
-                             Optional<Location> loc);
+                             std::optional<Location> loc);
 FIRRTLType inferBitwiseResult(FIRRTLType lhs, FIRRTLType rhs,
-                              Optional<Location> loc);
+                              std::optional<Location> loc);
 FIRRTLType inferComparisonResult(FIRRTLType lhs, FIRRTLType rhs,
-                                 Optional<Location> loc);
-FIRRTLType inferReductionResult(FIRRTLType arg, Optional<Location> loc);
+                                 std::optional<Location> loc);
+FIRRTLType inferReductionResult(FIRRTLType arg, std::optional<Location> loc);
 
 // Common parsed argument validation functions.
 LogicalResult validateBinaryOpArguments(ValueRange operands,
diff --git a/include/circt/Dialect/FIRRTL/Passes.h b/include/circt/Dialect/FIRRTL/Passes.h
index 86e7732b6..856fc7ea5 100644
--- a/include/circt/Dialect/FIRRTL/Passes.h
+++ b/include/circt/Dialect/FIRRTL/Passes.h
@@ -103,8 +103,6 @@ createBlackBoxReaderPass(llvm::Optional<mlir::StringRef> inputPrefix = {});
 
 std::unique_ptr<mlir::Pass> createGrandCentralPass();
 
-std::unique_ptr<mlir::Pass> createGrandCentralTapsPass();
-
 std::unique_ptr<mlir::Pass>
 createGrandCentralSignalMappingsPass(mlir::StringRef outputFilename = "");
 
diff --git a/include/circt/Dialect/FIRRTL/Passes.td b/include/circt/Dialect/FIRRTL/Passes.td
index 5015dd4d2..7785757b3 100644
--- a/include/circt/Dialect/FIRRTL/Passes.td
+++ b/include/circt/Dialect/FIRRTL/Passes.td
@@ -432,12 +432,6 @@ def GrandCentral : Pass<"firrtl-grand-central", "CircuitOp"> {
   ];
 }
 
-def GrandCentralTaps : Pass<"firrtl-grand-central-taps", "firrtl::CircuitOp"> {
-  let summary = "Generate code for grand central data and memory taps";
-  let constructor = "circt::firrtl::createGrandCentralTapsPass()";
-  let dependentDialects = ["sv::SVDialect", "circt::hw::HWDialect"];
-}
-
 def GrandCentralSignalMappings : Pass<"firrtl-grand-central-signal-mappings",
                                       "firrtl::CircuitOp"> {
   let summary = "Generate signal mappings that force/probe remote signals";
@@ -613,7 +607,7 @@ def LowerXMR : Pass<"firrtl-lower-xmr", "firrtl::CircuitOp"> {
 def LowerIntrinsics : Pass<"firrtl-lower-intrinsics", "firrtl::CircuitOp"> {
   let summary = "Lower intrinsics";
   let description = [{
-    This pass lowers intrinsics encoded as extmodule with annotation and 
+    This pass lowers intrinsics encoded as extmodule with annotation and
     intmodule to their implementation or op.
   }];
   let constructor = "circt::firrtl::createLowerIntrinsicsPass()";
diff --git a/include/circt/Dialect/HWArith/HWArithOps.td b/include/circt/Dialect/HWArith/HWArithOps.td
index bb4a2f144..12cb2c043 100644
--- a/include/circt/Dialect/HWArith/HWArithOps.td
+++ b/include/circt/Dialect/HWArith/HWArithOps.td
@@ -55,7 +55,7 @@ class BinOp<string mnemonic, list<Trait> traits = []> :
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/include/circt/Dialect/LLHD/IR/SignalOps.td b/include/circt/Dialect/LLHD/IR/SignalOps.td
index 4425e8bd9..87a0b29b2 100644
--- a/include/circt/Dialect/LLHD/IR/SignalOps.td
+++ b/include/circt/Dialect/LLHD/IR/SignalOps.td
@@ -278,7 +278,7 @@ def LLHD_RegOp : LLHD_Op<"reg", [
   let extraClassDeclaration = [{
     static StringRef getModeAttrName() { return "modes"; }
     static RegMode getRegModeByName(StringRef name) {
-      llvm::Optional<RegMode> optional =  symbolizeRegMode(name);
+      std::optional<RegMode> optional =  symbolizeRegMode(name);
       assert(optional && "Invalid RegMode string.");
       return optional.value();
     }
diff --git a/include/circt/Dialect/SV/SVExpressions.td b/include/circt/Dialect/SV/SVExpressions.td
index 126535c27..eedb1288c 100644
--- a/include/circt/Dialect/SV/SVExpressions.td
+++ b/include/circt/Dialect/SV/SVExpressions.td
@@ -229,7 +229,7 @@ def IndexedPartSelectOp
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/include/circt/Dialect/SV/SVInOutOps.td b/include/circt/Dialect/SV/SVInOutOps.td
index e3506078a..530147e60 100644
--- a/include/circt/Dialect/SV/SVInOutOps.td
+++ b/include/circt/Dialect/SV/SVInOutOps.td
@@ -184,7 +184,7 @@ def IndexedPartSelectInOutOp : SVOp<"indexed_part_select_inout",
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
@@ -214,7 +214,7 @@ def StructFieldInOutOp : SVOp<"struct_field_inout",
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/include/circt/Dialect/Seq/SeqTypes.td b/include/circt/Dialect/Seq/SeqTypes.td
index 63118cd1c..5ec64cecb 100644
--- a/include/circt/Dialect/Seq/SeqTypes.td
+++ b/include/circt/Dialect/Seq/SeqTypes.td
@@ -55,7 +55,7 @@ def HLMemType : SeqType<"HLMem",[
 
     /// Clone this vector type with the given shape and element type. If the
     /// provided shape is `None`, the current shape of the type is used.
-    HLMemType cloneWith(Optional<ArrayRef<int64_t>> shape,
+    HLMemType cloneWith(std::optional<ArrayRef<int64_t>> shape,
                          Type elementType) const;
   }];
 
diff --git a/include/circt/Dialect/SystemC/SystemCExpressions.td b/include/circt/Dialect/SystemC/SystemCExpressions.td
index 08b74aef8..9f98414cd 100644
--- a/include/circt/Dialect/SystemC/SystemCExpressions.td
+++ b/include/circt/Dialect/SystemC/SystemCExpressions.td
@@ -28,7 +28,7 @@ def SignalReadOp : SystemCOp<"signal.read", [Pure,
   let extraClassDeclaration = [{
     /// Infer the return types of this operation.
     static LogicalResult inferReturnTypes(MLIRContext *context,
-                                          Optional<Location> loc,
+                                          std::optional<Location> loc,
                                           ValueRange operands,
                                           DictionaryAttr attrs,
                                           mlir::RegionRange regions,
diff --git a/lib/Analysis/SchedulingAnalysis.cpp b/lib/Analysis/SchedulingAnalysis.cpp
index 0c9f58b03..37963edf1 100644
--- a/lib/Analysis/SchedulingAnalysis.cpp
+++ b/lib/Analysis/SchedulingAnalysis.cpp
@@ -72,7 +72,7 @@ void circt::analysis::CyclicSchedulingAnalysis::analyzeForOp(
       // assumes outer loops execute sequentially, i.e. one iteration of the
       // inner loop completes before the next iteration is initiated. With
       // proper analysis and lowerings, this can be relaxed.
-      unsigned distance = memoryDep.dependenceComponents.back().lb.value();
+      unsigned distance = *memoryDep.dependenceComponents.back().lb;
       if (distance > 0)
         problem.setDistance(dep, distance);
     }
diff --git a/lib/Analysis/TestPasses.cpp b/lib/Analysis/TestPasses.cpp
index faff16d10..3fad7d922 100644
--- a/lib/Analysis/TestPasses.cpp
+++ b/lib/Analysis/TestPasses.cpp
@@ -61,9 +61,9 @@ void TestDependenceAnalysisPass::runOnOperation() {
       for (auto comp : dep.dependenceComponents) {
         SmallVector<Attribute> vector;
         vector.push_back(
-            IntegerAttr::get(IntegerType::get(context, 64), comp.lb.value()));
+            IntegerAttr::get(IntegerType::get(context, 64), *comp.lb));
         vector.push_back(
-            IntegerAttr::get(IntegerType::get(context, 64), comp.ub.value()));
+            IntegerAttr::get(IntegerType::get(context, 64), *comp.ub));
         comps.push_back(ArrayAttr::get(context, vector));
       }
 
diff --git a/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp b/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
index 49bfee9c5..b90508f48 100644
--- a/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
+++ b/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
@@ -361,7 +361,7 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
   // iter arg is created for the induction variable.
   TypeRange resultTypes = innerLoop.getResultTypes();
 
-  auto ii = builder.getI64IntegerAttr(problem.getInitiationInterval().value());
+  auto ii = builder.getI64IntegerAttr(*problem.getInitiationInterval());
 
   SmallVector<Value> iterArgs;
   iterArgs.push_back(lowerBound);
diff --git a/lib/Conversion/ExportChiselInterface/ExportChiselInterface.cpp b/lib/Conversion/ExportChiselInterface/ExportChiselInterface.cpp
index cce7199a7..08505e353 100644
--- a/lib/Conversion/ExportChiselInterface/ExportChiselInterface.cpp
+++ b/lib/Conversion/ExportChiselInterface/ExportChiselInterface.cpp
@@ -89,7 +89,7 @@ static LogicalResult emitPortType(Location location, FIRRTLBaseType type,
           location, "Expected width to be inferred for exported port"));
     }
     return emitTypeWithArguments(name, [&](bool) {
-      os << width.value() << ".W";
+      os << *width << ".W";
       return success();
     });
   };
diff --git a/lib/Conversion/FIRRTLToHW/LowerToHW.cpp b/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
index ecb02afb8..497dfca48 100644
--- a/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
+++ b/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
@@ -3406,10 +3406,10 @@ LogicalResult FIRRTLLowering::visitExpr(InvalidValueOp op) {
   // do.
   if (auto bitwidth =
           firrtl::getBitWidth(op.getType().cast<FIRRTLBaseType>())) {
-    if (bitwidth.value() == 0) // Let the caller handle zero width values.
+    if (*bitwidth == 0) // Let the caller handle zero width values.
       return failure();
 
-    auto constant = getOrCreateIntConstant(bitwidth.value(), 0);
+    auto constant = getOrCreateIntConstant(*bitwidth, 0);
     // If the result is an aggregate value, we have to bitcast the constant.
     if (!resultTy.isa<IntegerType>())
       constant = builder.create<hw::BitcastOp>(resultTy, constant);
@@ -4096,6 +4096,24 @@ LogicalResult FIRRTLLowering::visitStmt(AttachOp op) {
   if (getSingleNonInstanceOperand(op))
     return success();
 
+  // If all operands of the attach are internal to this module (none of them
+  // are ports), then they can all be replaced with a single wire, and we can
+  // delete the attach op.
+  bool isAttachInternalOnly =
+      llvm::none_of(inoutValues, [](auto v) { return isa<BlockArgument>(v); });
+
+  if (isAttachInternalOnly) {
+    auto v0 = inoutValues.front();
+    for (auto v : inoutValues) {
+      if (v == v0)
+        continue;
+      v.replaceAllUsesWith(v0);
+    }
+    return success();
+  }
+
+  // If the attach operands contain a port, then we can't do anything to
+  // simplify the attach operation.
   addToIfDefBlock(
       "SYNTHESIS",
       // If we're doing synthesis, we emit an all-pairs assign complex.
diff --git a/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp b/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp
index b894d4a15..1598130a9 100644
--- a/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp
+++ b/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp
@@ -2195,27 +2195,27 @@ FModuleOp buildInnerFIFO(CircuitOp circuit, StringRef moduleName,
 
     // Get the clock out of the bundle and connect them.
     auto readClock = builder.create<SubfieldOp>(
-        readBundle, readType.getElementIndex("clk").value());
+        readBundle, *readType.getElementIndex("clk"));
     builder.create<ConnectOp>(readClock, clk);
     auto writeClock = builder.create<SubfieldOp>(
-        writeBundle, writeType.getElementIndex("clk").value());
+        writeBundle, *writeType.getElementIndex("clk"));
     builder.create<ConnectOp>(writeClock, clk);
 
     // Get the addresses out of the bundle
     auto readAddr = builder.create<SubfieldOp>(
-        readBundle, readType.getElementIndex("addr").value());
+        readBundle, *readType.getElementIndex("addr"));
     auto writeAddr = builder.create<SubfieldOp>(
-        writeBundle, readType.getElementIndex("addr").value());
+        writeBundle, *readType.getElementIndex("addr"));
 
     // Connect read and write to head and tail registers.
     builder.create<ConnectOp>(readAddr, head);
     builder.create<ConnectOp>(writeAddr, tail);
 
     // Get the memory enable out of the bundles.
-    auto memReadEn = builder.create<SubfieldOp>(
-        readBundle, readType.getElementIndex("en").value());
+    auto memReadEn =
+        builder.create<SubfieldOp>(readBundle, *readType.getElementIndex("en"));
     auto memWriteEn = builder.create<SubfieldOp>(
-        writeBundle, writeType.getElementIndex("en").value());
+        writeBundle, *writeType.getElementIndex("en"));
     // Always read
     builder.create<ConnectOp>(memReadEn, oneConst);
     // Write on writeEn
@@ -2223,15 +2223,15 @@ FModuleOp buildInnerFIFO(CircuitOp circuit, StringRef moduleName,
 
     // Connect read and write data.
     auto readData = builder.create<SubfieldOp>(
-        readBundle, readType.getElementIndex("data").value());
+        readBundle, *readType.getElementIndex("data"));
     auto writeData = builder.create<SubfieldOp>(
-        writeBundle, writeType.getElementIndex("data").value());
+        writeBundle, *writeType.getElementIndex("data"));
     builder.create<ConnectOp>(dataOut, readData);
     builder.create<ConnectOp>(writeData, dataIn);
 
     // Get the store mask out of the bundle.
     auto writeMask = builder.create<SubfieldOp>(
-        writeBundle, writeType.getElementIndex("mask").value());
+        writeBundle, *writeType.getElementIndex("mask"));
 
     // We might be storing bundles. Therefore, we have to ensure that writeEn is
     // connected to all elements of the mask.
@@ -2639,12 +2639,12 @@ bool HandshakeBuilder::visitHandshake(MemoryOp op) {
 
     // Get the clock out of the bundle and connect it.
     auto memClock = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("clk").value());
+        insertLoc, memBundle, *memType.getElementIndex("clk"));
     rewriter.create<ConnectOp>(insertLoc, memClock, clock);
 
     // Get the load address out of the bundle.
     auto memAddr = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("addr").value());
+        insertLoc, memBundle, *memType.getElementIndex("addr"));
 
     // Since addresses coming from Handshake are IndexType and have a hardcoded
     // 64-bit width in this pass, we may need to truncate down to the actual
@@ -2664,14 +2664,14 @@ bool HandshakeBuilder::visitHandshake(MemoryOp op) {
 
     // Get the load data out of the bundle.
     auto memData = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("data").value());
+        insertLoc, memBundle, *memType.getElementIndex("data"));
 
     // Connect the memory to the load data.
     rewriter.create<ConnectOp>(insertLoc, loadDataData, memData);
 
     // Get the load enable out of the bundle.
     auto memEnable = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("en").value());
+        insertLoc, memBundle, *memType.getElementIndex("en"));
 
     // Connect the address valid signal to the memory enable.
     rewriter.create<ConnectOp>(insertLoc, memEnable, loadAddrValid);
@@ -2707,12 +2707,12 @@ bool HandshakeBuilder::visitHandshake(MemoryOp op) {
 
     // Get the clock out of the bundle and connect it.
     auto memClock = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("clk").value());
+        insertLoc, memBundle, *memType.getElementIndex("clk"));
     rewriter.create<ConnectOp>(insertLoc, memClock, clock);
 
     // Get the store address out of the bundle.
     auto memAddr = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("addr").value());
+        insertLoc, memBundle, *memType.getElementIndex("addr"));
 
     // Since addresses coming from Handshake are IndexType and have a hardcoded
     // 64-bit width in this pass, we may need to truncate down to the actual
@@ -2732,7 +2732,7 @@ bool HandshakeBuilder::visitHandshake(MemoryOp op) {
 
     // Get the store data out of the bundle.
     auto memData = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("data").value());
+        insertLoc, memBundle, *memType.getElementIndex("data"));
 
     // Connect the store data to the memory.
     rewriter.create<ConnectOp>(insertLoc, memData, storeDataData);
@@ -2786,14 +2786,14 @@ bool HandshakeBuilder::visitHandshake(MemoryOp op) {
 
     // Get the store enable out of the bundle.
     auto memEnable = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("en").value());
+        insertLoc, memBundle, *memType.getElementIndex("en"));
 
     // Connect the write valid signal to the memory enable.
     rewriter.create<ConnectOp>(insertLoc, memEnable, writeValid);
 
     // Get the store mask out of the bundle.
     auto memMask = rewriter.create<SubfieldOp>(
-        insertLoc, memBundle, memType.getElementIndex("mask").value());
+        insertLoc, memBundle, *memType.getElementIndex("mask"));
 
     // Since we are not storing bundles in the memory, we can assume the mask is
     // a single bit.
@@ -3097,7 +3097,7 @@ struct HandshakeFuncOpLowering : public OpConversionPattern<handshake::FuncOp> {
         funcOp, /*numClocks=*/1, rewriter, setFlattenAttr);
     if (failed(maybeTopModuleOp))
       return failure();
-    auto topModuleOp = maybeTopModuleOp.value();
+    auto topModuleOp = *maybeTopModuleOp;
     inlineFuncRegion(funcOp, topModuleOp, rewriter);
 
     NameUniquer instanceUniquer = [&](Operation *op) {
diff --git a/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp b/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
index 9e15e9f36..7c33b717e 100644
--- a/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
+++ b/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
@@ -62,7 +62,7 @@ public:
     return getOperation().getCondBlock().getTerminator()->getOperand(0);
   }
 
-  Optional<uint64_t> getBound() override {
+  std::optional<uint64_t> getBound() override {
     return getOperation().getTripCount();
   }
 };
diff --git a/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp b/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
index f8f8a6b86..919093869 100644
--- a/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
+++ b/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
@@ -64,7 +64,7 @@ public:
     return getOperation().getConditionOp().getOperand(0);
   }
 
-  Optional<uint64_t> getBound() override { return std::nullopt; }
+  std::optional<uint64_t> getBound() override { return std::nullopt; }
 };
 
 //===----------------------------------------------------------------------===//
diff --git a/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp b/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp
index 0b005e401..1feac58af 100644
--- a/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp
+++ b/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp
@@ -594,7 +594,7 @@ static void reconnectMergeOps(Region &r,
           // are not the block's control merge must have an index operand (at
           // this point, an index backedge)
           assert(mergeInfo.indexEdge.has_value());
-          mergeInfo.indexEdge.value().setValue(cntrlMg->getResult(1));
+          (*mergeInfo.indexEdge).setValue(cntrlMg->getResult(1));
         }
       }
     }
diff --git a/lib/Dialect/Calyx/CalyxOps.cpp b/lib/Dialect/Calyx/CalyxOps.cpp
index 37b025af3..f44ade86a 100644
--- a/lib/Dialect/Calyx/CalyxOps.cpp
+++ b/lib/Dialect/Calyx/CalyxOps.cpp
@@ -309,7 +309,7 @@ static void eraseControlWithGroupAndConditional(OpTy op,
 
   // Save information about the operation, and erase it.
   Value cond = op.getCond();
-  Optional<StringRef> groupName = op.getGroupName();
+  std::optional<StringRef> groupName = op.getGroupName();
   auto component = op->template getParentOfType<ComponentOp>();
   rewriter.eraseOp(op);
 
@@ -1895,7 +1895,7 @@ LogicalResult IfOp::verify() {
   if (elseBodyExists() && getElseBody()->empty())
     return emitError() << "empty 'else' region.";
 
-  Optional<StringRef> optGroupName = getGroupName();
+  std::optional<StringRef> optGroupName = getGroupName();
   if (!optGroupName) {
     // No combinational group was provided.
     return success();
@@ -2097,7 +2097,7 @@ LogicalResult WhileOp::verify() {
   auto component = (*this)->getParentOfType<ComponentOp>();
   auto wiresOp = component.getWiresOp();
 
-  Optional<StringRef> optGroupName = getGroupName();
+  std::optional<StringRef> optGroupName = getGroupName();
   if (!optGroupName) {
     /// No combinational group was provided
     return success();
diff --git a/lib/Dialect/Calyx/Export/CalyxEmitter.cpp b/lib/Dialect/Calyx/Export/CalyxEmitter.cpp
index 4e68ac77f..a728b7400 100644
--- a/lib/Dialect/Calyx/Export/CalyxEmitter.cpp
+++ b/lib/Dialect/Calyx/Export/CalyxEmitter.cpp
@@ -301,7 +301,7 @@ private:
     if (!identifierOpt.has_value())
       return "";
 
-    StringRef identifier = identifierOpt.value();
+    StringRef identifier = *identifierOpt;
     // Verify this attribute is supported for emission.
     if (!isValidCalyxAttribute(identifier))
       return "";
diff --git a/lib/Dialect/Comb/CombOps.cpp b/lib/Dialect/Comb/CombOps.cpp
index c69a99ce6..d4a502288 100644
--- a/lib/Dialect/Comb/CombOps.cpp
+++ b/lib/Dialect/Comb/CombOps.cpp
@@ -261,7 +261,7 @@ void ConcatOp::build(OpBuilder &builder, OperationState &result, Value hd,
 }
 
 LogicalResult ConcatOp::inferReturnTypes(MLIRContext *context,
-                                         Optional<Location> loc,
+                                         std::optional<Location> loc,
                                          ValueRange operands,
                                          DictionaryAttr attrs,
                                          mlir::RegionRange regions,
diff --git a/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp b/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
index e1046d727..c1043c6a4 100644
--- a/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
+++ b/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
@@ -119,7 +119,7 @@ void MemoryPortOp::build(OpBuilder &builder, OperationState &result,
 }
 
 LogicalResult MemoryPortOp::inferReturnTypes(MLIRContext *context,
-                                             Optional<Location> loc,
+                                             std::optional<Location> loc,
                                              ValueRange operands,
                                              DictionaryAttr attrs,
                                              mlir::RegionRange regions,
@@ -193,7 +193,7 @@ void MemoryDebugPortOp::build(OpBuilder &builder, OperationState &result,
 }
 
 LogicalResult MemoryDebugPortOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   auto inType = operands[0].getType();
diff --git a/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp b/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
index 2e408b5b1..b84bece80 100644
--- a/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
@@ -11,7 +11,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h"
+#include "circt/Dialect/FIRRTL/AnnotationDetails.h"
+#include "circt/Dialect/FIRRTL/FIRRTLUtils.h"
 #include "mlir/IR/ImplicitLocOpBuilder.h"
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "lower-annos"
 
 using namespace circt;
 using namespace firrtl;
@@ -497,3 +502,379 @@ firrtl::findLCAandSetPath(AnnoPathValue &srcTarget, AnnoPathValue &dstTarget,
                           dstPathFromTop.end());
   return success();
 }
+
+//===----------------------------------------------------------------------===//
+// Code related to handling Grand Central Data/Mem Taps annotations
+//===----------------------------------------------------------------------===//
+
+static Value lowerInternalPathAnno(AnnoPathValue &srcTarget,
+                                   const AnnoPathValue &moduleTarget,
+                                   const AnnoPathValue &target,
+                                   StringAttr internalPathAttr,
+                                   FIRRTLType targetType, ApplyState &state) {
+  Value sendVal;
+  FModuleLike mod = cast<FModuleLike>(moduleTarget.ref.getOp());
+  InstanceOp modInstance;
+  if (!moduleTarget.instances.empty()) {
+    modInstance = moduleTarget.instances.back();
+  } else {
+    auto *node = state.instancePathCache.instanceGraph.lookup(
+        cast<hw::HWModuleLike>((Operation *)mod));
+    if (!node->hasOneUse()) {
+      mod->emitOpError(
+          "cannot be used for DataTaps, it is instantiated multiple times");
+      return nullptr;
+    }
+    modInstance = cast<InstanceOp>((*node->uses().begin())->getInstance());
+  }
+  ImplicitLocOpBuilder builder(modInstance.getLoc(), modInstance);
+  builder.setInsertionPointAfter(modInstance);
+  auto portRefType = RefType::get(targetType.cast<FIRRTLBaseType>());
+  SmallString<32> refName;
+  for (auto c : internalPathAttr.getValue()) {
+    switch (c) {
+    case '.':
+    case '[':
+      refName.push_back('_');
+      break;
+    case ']':
+      break;
+    default:
+      refName.push_back(c);
+      break;
+    }
+  }
+
+  // Add RefType ports corresponding to this "internalPath" to the external
+  // module. This also updates all the instances of the external module.
+  // This removes and replaces the instance, and returns the updated
+  // instance.
+  modInstance = addPortsToModule(
+      mod, modInstance, portRefType, Direction::Out, refName,
+      state.instancePathCache,
+      [&](FModuleLike mod) -> ModuleNamespace & {
+        return state.getNamespace(mod);
+      },
+      &state.targetCaches);
+  // Since the instance op generates the RefType output, no need of another
+  // RefSendOp.  Store into an op to ensure we have stable reference,
+  // so future tapping won't invalidate this Value.
+  sendVal = modInstance.getResults().back();
+  sendVal =
+      builder
+          .create<mlir::UnrealizedConversionCastOp>(sendVal.getType(), sendVal)
+          ->getResult(0);
+
+  // Now set the instance as the source for the final datatap xmr.
+  srcTarget = AnnoPathValue(modInstance);
+  if (auto extMod = dyn_cast<FExtModuleOp>((Operation *)mod)) {
+    // The extern module can have other internal paths attached to it,
+    // append this to them.
+    SmallVector<Attribute> paths(extMod.getInternalPathsAttr().getValue());
+    paths.push_back(internalPathAttr);
+    extMod.setInternalPathsAttr(builder.getArrayAttr(paths));
+  } else if (auto intMod = dyn_cast<FModuleOp>((Operation *)mod)) {
+    auto builder = ImplicitLocOpBuilder::atBlockEnd(
+        intMod.getLoc(), &intMod.getBody().getBlocks().back());
+    auto pathStr = builder.create<VerbatimExprOp>(
+        portRefType.getType(), internalPathAttr.getValue(), ValueRange{});
+    auto sendPath = builder.create<RefSendOp>(pathStr);
+    builder.create<StrictConnectOp>(intMod.getArguments().back(),
+                                    sendPath.getResult());
+  }
+
+  if (!moduleTarget.instances.empty())
+    srcTarget.instances = moduleTarget.instances;
+  else {
+    auto path = state.instancePathCache
+                    .getAbsolutePaths(modInstance->getParentOfType<FModuleOp>())
+                    .back();
+    srcTarget.instances.append(path.begin(), path.end());
+  }
+  return sendVal;
+}
+
+// Describes tap points into the design.  This has the following structure:
+//   keys: Seq[DataTapKey]
+// DataTapKey has multiple implementations:
+//   - ReferenceDataTapKey: (tapping a point which exists in the FIRRTL)
+//       sink: ReferenceTarget
+//       source: ReferenceTarget
+//   - DataTapModuleSignalKey: (tapping a point, by name, in a blackbox)
+//       module: IsModule
+//       internalPath: String
+//       sink: ReferenceTarget
+//   - DeletedDataTapKey: (not implemented here)
+//       sink: ReferenceTarget
+//   - LiteralDataTapKey: (not implemented here)
+//       literal: Literal
+//       sink: ReferenceTarget
+// A Literal is a FIRRTL IR literal serialized to a string.  For now, just
+// store the string.
+// TODO: Parse the literal string into a UInt or SInt literal.
+LogicalResult circt::firrtl::applyGCTDataTaps(const AnnoPathValue &target,
+                                              DictionaryAttr anno,
+                                              ApplyState &state) {
+  auto *context = state.circuit.getContext();
+  auto loc = state.circuit.getLoc();
+
+  // Process all the taps.
+  auto keyAttr = tryGetAs<ArrayAttr>(anno, anno, "keys", loc, dataTapsClass);
+  if (!keyAttr)
+    return failure();
+  for (size_t i = 0, e = keyAttr.size(); i != e; ++i) {
+    auto b = keyAttr[i];
+    auto path = ("keys[" + Twine(i) + "]").str();
+    auto bDict = b.cast<DictionaryAttr>();
+    auto classAttr =
+        tryGetAs<StringAttr>(bDict, anno, "class", loc, dataTapsClass, path);
+    if (!classAttr)
+      return failure();
+    // Can only handle ReferenceDataTapKey and DataTapModuleSignalKey
+    if (classAttr.getValue() != referenceKeyClass &&
+        classAttr.getValue() != internalKeyClass)
+      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
+                                      "' with path '" +
+                                      (Twine(path) + ".class") +
+                                      "' contained an unknown/unimplemented "
+                                      "DataTapKey class '" +
+                                      classAttr.getValue() + "'.")
+                 .attachNote()
+             << "The full Annotation is reproduced here: " << anno << "\n";
+
+    auto sinkNameAttr =
+        tryGetAs<StringAttr>(bDict, anno, "sink", loc, dataTapsClass, path);
+    std::string wirePathStr;
+    if (sinkNameAttr)
+      wirePathStr = canonicalizeTarget(sinkNameAttr.getValue());
+    if (!wirePathStr.empty())
+      if (!tokenizePath(wirePathStr))
+        wirePathStr.clear();
+    Optional<AnnoPathValue> wireTarget = std::nullopt;
+    if (!wirePathStr.empty())
+      wireTarget = resolvePath(wirePathStr, state.circuit, state.symTbl,
+                               state.targetCaches);
+    if (!wireTarget)
+      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
+                                      "' with wire path '" + wirePathStr +
+                                      "' couldnot be resolved.");
+    if (!wireTarget->ref.getImpl().isOp())
+      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
+                                      "' with path '" +
+                                      (Twine(path) + ".class") +
+                                      "' cannot specify a port for sink.");
+    // Extract the name of the wire, used for datatap.
+    auto tapName = StringAttr::get(
+        context, wirePathStr.substr(wirePathStr.find_last_of('>') + 1));
+    Optional<AnnoPathValue> srcTarget = std::nullopt;
+    Value sendVal;
+    if (classAttr.getValue() == internalKeyClass) {
+      // For DataTapModuleSignalKey, the source is encoded as a string, that
+      // should exist inside the specified module. This source string is used as
+      // a suffix to the instance name for the module inside a VerbatimExprOp.
+      // This verbatim represents an intermediate xmr, which is then used by a
+      // ref.send to be read remotely.
+      auto internalPathAttr = tryGetAs<StringAttr>(bDict, anno, "internalPath",
+                                                   loc, dataTapsClass, path);
+      auto moduleAttr =
+          tryGetAs<StringAttr>(bDict, anno, "module", loc, dataTapsClass, path);
+      if (!internalPathAttr || !moduleAttr)
+        return failure();
+      auto moduleTargetStr = canonicalizeTarget(moduleAttr.getValue());
+      if (!tokenizePath(moduleTargetStr))
+        return failure();
+      Optional<AnnoPathValue> moduleTarget = resolvePath(
+          moduleTargetStr, state.circuit, state.symTbl, state.targetCaches);
+      if (!moduleTarget)
+        return failure();
+      AnnoPathValue internalPathSrc;
+      auto targetType = wireTarget->ref.getType().cast<FIRRTLBaseType>();
+      if (wireTarget->fieldIdx)
+        targetType = targetType.getFinalTypeByFieldID(wireTarget->fieldIdx);
+      sendVal = lowerInternalPathAnno(internalPathSrc, *moduleTarget, target,
+                                      internalPathAttr, targetType, state);
+      if (!sendVal)
+        return failure();
+      srcTarget = internalPathSrc;
+    } else {
+      // Now handle ReferenceDataTapKey. Get the source from annotation.
+      auto sourceAttr =
+          tryGetAs<StringAttr>(bDict, anno, "source", loc, dataTapsClass, path);
+      if (!sourceAttr)
+        return failure();
+      auto sourcePathStr = canonicalizeTarget(sourceAttr.getValue());
+      if (!tokenizePath(sourcePathStr))
+        return failure();
+      LLVM_DEBUG(llvm::dbgs() << "\n Drill xmr path from :" << sourcePathStr
+                              << " to " << wirePathStr);
+      srcTarget = resolvePath(sourcePathStr, state.circuit, state.symTbl,
+                              state.targetCaches);
+    }
+    if (!srcTarget)
+      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
+                                      "' source path couldnot be resolved.");
+
+    auto wireModule =
+        cast<FModuleOp>(wireTarget->ref.getModule().getOperation());
+
+    if (auto extMod = dyn_cast<FExtModuleOp>(srcTarget->ref.getOp())) {
+      // If the source is a port on extern module, then move the source to the
+      // instance port for the ext module.
+      auto portNo = srcTarget->ref.getImpl().getPortNo();
+      auto lastInst = srcTarget->instances.pop_back_val();
+      auto builder = ImplicitLocOpBuilder::atBlockEnd(lastInst.getLoc(),
+                                                      lastInst->getBlock());
+      builder.setInsertionPointAfter(lastInst);
+      // Instance port cannot be used as an annotation target, so use a NodeOp.
+      auto node = builder.create<NodeOp>(lastInst.getType(portNo),
+                                         lastInst.getResult(portNo));
+      AnnotationSet::addDontTouch(node);
+      srcTarget->ref = AnnoTarget(circt::firrtl::detail::AnnoTargetImpl(node));
+    }
+
+    // The RefSend value can be either generated by the instance of an external
+    // module or a RefSendOp.
+    if (!sendVal) {
+      auto srcModule =
+          dyn_cast<FModuleOp>(srcTarget->ref.getModule().getOperation());
+
+      ImplicitLocOpBuilder sendBuilder(srcModule.getLoc(), srcModule);
+      // Set the insertion point for the RefSend, it should be dominated by the
+      // srcTarget value. If srcTarget is a port, then insert the RefSend
+      // at the beggining of the module, else define the RefSend at the end of
+      // the block that contains the srcTarget Op.
+      if (srcTarget->ref.getImpl().isOp()) {
+        sendVal = srcTarget->ref.getImpl().getOp()->getResult(0);
+        sendBuilder.setInsertionPointAfter(srcTarget->ref.getOp());
+      } else if (srcTarget->ref.getImpl().isPort()) {
+        sendVal = srcModule.getArgument(srcTarget->ref.getImpl().getPortNo());
+        sendBuilder.setInsertionPointToStart(srcModule.getBodyBlock());
+      }
+      // If the target value is a field of an aggregate create the
+      // subfield/subaccess into it.
+      sendVal = getValueByFieldID(sendBuilder, sendVal, srcTarget->fieldIdx);
+      // Note: No DontTouch added to sendVal, it can be constantprop'ed or
+      // CSE'ed.
+    }
+
+    auto *targetOp = wireTarget->ref.getOp();
+    auto sinkBuilder = ImplicitLocOpBuilder::atBlockEnd(wireModule.getLoc(),
+                                                        targetOp->getBlock());
+    auto wireType = cast<FIRRTLBaseType>(targetOp->getResult(0).getType());
+    // Get type of sent value, if already a RefType, the base type.
+    auto valType = getBaseType(cast<FIRRTLType>(sendVal.getType()));
+    Value sink = getValueByFieldID(sinkBuilder, targetOp->getResult(0),
+                                   wireTarget->fieldIdx);
+
+    // For resets, sometimes inject a cast between sink and target 'sink'.
+    // Introduced a dummy wire and cast that, dummy wire will be 'sink'.
+    if (valType.isResetType() &&
+        valType.getWidthlessType() != wireType.getWidthlessType()) {
+      // Helper: create a wire, cast it with callback, connect cast to sink.
+      auto addWireWithCast = [&](auto createCast) {
+        auto wire = sinkBuilder.create<WireOp>(
+            valType,
+            state.getNamespace(wireModule).newName(tapName.getValue()));
+        sinkBuilder.create<ConnectOp>(sink, createCast(wire));
+        sink = wire;
+      };
+      if (isa<IntType>(wireType))
+        addWireWithCast([&](auto v) {
+          return sinkBuilder.create<AsUIntPrimOp>(wireType, v);
+        });
+      else if (isa<AsyncResetType>(wireType))
+        addWireWithCast(
+            [&](auto v) { return sinkBuilder.create<AsAsyncResetPrimOp>(v); });
+    }
+
+    state.wiringProblems.push_back({sendVal, sink, ""});
+  }
+
+  return success();
+}
+
+LogicalResult circt::firrtl::applyGCTMemTaps(const AnnoPathValue &target,
+                                             DictionaryAttr anno,
+                                             ApplyState &state) {
+  auto loc = state.circuit.getLoc();
+
+  auto sourceAttr =
+      tryGetAs<StringAttr>(anno, anno, "source", loc, memTapClass);
+  if (!sourceAttr)
+    return failure();
+  auto sourceTargetStr = canonicalizeTarget(sourceAttr.getValue());
+
+  Value memDbgPort;
+  Optional<AnnoPathValue> srcTarget = resolvePath(
+      sourceTargetStr, state.circuit, state.symTbl, state.targetCaches);
+  if (!srcTarget)
+    return mlir::emitError(loc, "cannot resolve source target path '")
+           << sourceTargetStr << "'";
+  auto tapsAttr = tryGetAs<ArrayAttr>(anno, anno, "sink", loc, memTapClass);
+  if (!tapsAttr || tapsAttr.empty())
+    return mlir::emitError(loc, "sink must have at least one entry");
+  if (auto combMem = dyn_cast<chirrtl::CombMemOp>(srcTarget->ref.getOp())) {
+    if (!combMem.getType().getElementType().isGround())
+      return combMem.emitOpError(
+          "cannot generate MemTap to a memory with aggregate data type");
+    ImplicitLocOpBuilder builder(combMem->getLoc(), combMem);
+    builder.setInsertionPointAfter(combMem);
+    // Construct the type for the debug port.
+    auto debugType =
+        RefType::get(FVectorType::get(combMem.getType().getElementType(),
+                                      combMem.getType().getNumElements()));
+
+    auto debugPort = builder.create<chirrtl::MemoryDebugPortOp>(
+        debugType, combMem,
+        state.getNamespace(srcTarget->ref.getModule()).newName("memTap"));
+
+    memDbgPort = debugPort.getResult();
+    if (srcTarget->instances.empty()) {
+      auto path = state.instancePathCache.getAbsolutePaths(
+          combMem->getParentOfType<FModuleOp>());
+      if (path.size() > 1)
+        return combMem.emitOpError(
+            "cannot be resolved as source for MemTap, multiple paths from top "
+            "exist and unique instance cannot be resolved");
+      srcTarget->instances.append(path.back().begin(), path.back().end());
+    }
+    if (tapsAttr.size() != combMem.getType().getNumElements())
+      return mlir::emitError(
+          loc, "sink cannot specify more taps than the depth of the memory");
+  } else
+    return srcTarget->ref.getOp()->emitOpError(
+        "unsupported operation, only CombMem can be used as the source of "
+        "MemTap");
+
+  auto tap = tapsAttr[0].dyn_cast_or_null<StringAttr>();
+  if (!tap) {
+    return mlir::emitError(
+               loc, "Annotation '" + Twine(memTapClass) +
+                        "' with path '.taps[0" +
+                        "]' contained an unexpected type (expected a string).")
+               .attachNote()
+           << "The full Annotation is reprodcued here: " << anno << "\n";
+  }
+  auto wireTargetStr = canonicalizeTarget(tap.getValue());
+  if (!tokenizePath(wireTargetStr))
+    return failure();
+  Optional<AnnoPathValue> wireTarget = resolvePath(
+      wireTargetStr, state.circuit, state.symTbl, state.targetCaches);
+  if (!wireTarget)
+    return mlir::emitError(loc, "Annotation '" + Twine(memTapClass) +
+                                    "' with path '.taps[0]' contains target '" +
+                                    wireTargetStr +
+                                    "' that cannot be resolved.")
+               .attachNote()
+           << "The full Annotation is reproduced here: " << anno << "\n";
+
+  auto sendVal = memDbgPort;
+  if (wireTarget->ref.getOp()->getResult(0).getType() !=
+      cast<RefType>(sendVal.getType()).getType())
+    return wireTarget->ref.getOp()->emitError(
+        "cannot generate the MemTap, wiretap Type does not match the memory "
+        "type");
+  auto sink = wireTarget->ref.getOp()->getResult(0);
+  state.wiringProblems.push_back({sendVal, sink, "memTap"});
+  return success();
+}
diff --git a/lib/Dialect/FIRRTL/FIRRTLOps.cpp b/lib/Dialect/FIRRTL/FIRRTLOps.cpp
index d05eeb836..16b1f4856 100644
--- a/lib/Dialect/FIRRTL/FIRRTLOps.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLOps.cpp
@@ -2181,10 +2181,10 @@ void WhenOp::build(OpBuilder &builder, OperationState &result, Value condition,
 /// result value, so the FIRRTL-specific type inference ops directly return the
 /// inferred type rather than pushing into the `results` vector.
 LogicalResult impl::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, RegionRange regions, SmallVectorImpl<Type> &results,
     llvm::function_ref<FIRRTLType(ValueRange, ArrayRef<NamedAttribute>,
-                                  Optional<Location>)>
+                                  std::optional<Location>)>
         callback) {
   auto type = callback(
       operands, attrs ? attrs.getValue() : ArrayRef<NamedAttribute>{}, loc);
@@ -2590,7 +2590,7 @@ bool firrtl::isConstant(Value value) {
 
 FIRRTLType SubfieldOp::inferReturnType(ValueRange operands,
                                        ArrayRef<NamedAttribute> attrs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   auto inType = operands[0].getType().cast<BundleType>();
   auto fieldIndex =
       getAttr<IntegerAttr>(attrs, "fieldIndex").getValue().getZExtValue();
@@ -2614,7 +2614,7 @@ bool SubfieldOp::isFieldFlipped() {
 
 FIRRTLType SubindexOp::inferReturnType(ValueRange operands,
                                        ArrayRef<NamedAttribute> attrs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   auto inType = operands[0].getType();
   auto fieldIdx =
       getAttr<IntegerAttr>(attrs, "index").getValue().getZExtValue();
@@ -2635,7 +2635,7 @@ FIRRTLType SubindexOp::inferReturnType(ValueRange operands,
 
 FIRRTLType SubaccessOp::inferReturnType(ValueRange operands,
                                         ArrayRef<NamedAttribute> attrs,
-                                        Optional<Location> loc) {
+                                        std::optional<Location> loc) {
   auto inType = operands[0].getType();
   auto indexType = operands[1].getType();
 
@@ -2683,7 +2683,7 @@ void MultibitMuxOp::print(OpAsmPrinter &p) {
 
 FIRRTLType MultibitMuxOp::inferReturnType(ValueRange operands,
                                           ArrayRef<NamedAttribute> attrs,
-                                          Optional<Location> loc) {
+                                          std::optional<Location> loc) {
   if (operands.size() < 2) {
     if (loc)
       mlir::emitError(*loc, "at least one input is required");
@@ -2712,7 +2712,7 @@ FIRRTLType MultibitMuxOp::inferReturnType(ValueRange operands,
 /// On failure, this reports and error and returns false.  This function should
 /// not be used if you don't want an error reported.
 static bool isSameIntTypeKind(Type lhs, Type rhs, int32_t &lhsWidth,
-                              int32_t &rhsWidth, Optional<Location> loc) {
+                              int32_t &rhsWidth, std::optional<Location> loc) {
   // Must have two integer types with the same signedness.
   auto lhsi = lhs.dyn_cast<IntType>();
   auto rhsi = rhs.dyn_cast<IntType>();
@@ -2758,7 +2758,7 @@ LogicalResult impl::validateBinaryOpArguments(ValueRange operands,
 }
 
 FIRRTLType impl::inferAddSubResult(FIRRTLType lhs, FIRRTLType rhs,
-                                   Optional<Location> loc) {
+                                   std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth, resultWidth = -1;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2769,7 +2769,7 @@ FIRRTLType impl::inferAddSubResult(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType MulPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                            Optional<Location> loc) {
+                                            std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth, resultWidth = -1;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2781,7 +2781,7 @@ FIRRTLType MulPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType DivPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                            Optional<Location> loc) {
+                                            std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2796,7 +2796,7 @@ FIRRTLType DivPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType RemPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                            Optional<Location> loc) {
+                                            std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth, resultWidth = -1;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2807,7 +2807,7 @@ FIRRTLType RemPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType impl::inferBitwiseResult(FIRRTLType lhs, FIRRTLType rhs,
-                                    Optional<Location> loc) {
+                                    std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth, resultWidth = -1;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2818,12 +2818,12 @@ FIRRTLType impl::inferBitwiseResult(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType impl::inferComparisonResult(FIRRTLType lhs, FIRRTLType rhs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   return UIntType::get(lhs.getContext(), 1);
 }
 
 FIRRTLType CatPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                            Optional<Location> loc) {
+                                            std::optional<Location> loc) {
   int32_t lhsWidth, rhsWidth, resultWidth = -1;
   if (!isSameIntTypeKind(lhs, rhs, lhsWidth, rhsWidth, loc))
     return {};
@@ -2834,7 +2834,7 @@ FIRRTLType CatPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType DShlPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                             Optional<Location> loc) {
+                                             std::optional<Location> loc) {
   auto lhsi = lhs.dyn_cast<IntType>();
   auto rhsui = rhs.dyn_cast<UIntType>();
   if (!rhsui || !lhsi) {
@@ -2870,7 +2870,7 @@ FIRRTLType DShlPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType DShlwPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                              Optional<Location> loc) {
+                                              std::optional<Location> loc) {
   if (!lhs.isa<IntType>() || !rhs.isa<UIntType>()) {
     if (loc)
       mlir::emitError(*loc,
@@ -2881,7 +2881,7 @@ FIRRTLType DShlwPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
 }
 
 FIRRTLType DShrPrimOp::inferBinaryReturnType(FIRRTLType lhs, FIRRTLType rhs,
-                                             Optional<Location> loc) {
+                                             std::optional<Location> loc) {
   if (!lhs.isa<IntType>() || !rhs.isa<UIntType>()) {
     if (loc)
       mlir::emitError(*loc,
@@ -2905,13 +2905,14 @@ LogicalResult impl::validateUnaryOpArguments(ValueRange operands,
   return success();
 }
 
-FIRRTLType SizeOfIntrinsicOp::inferUnaryReturnType(FIRRTLType arg,
-                                                   Optional<Location> loc) {
+FIRRTLType
+SizeOfIntrinsicOp::inferUnaryReturnType(FIRRTLType arg,
+                                        std::optional<Location> loc) {
   return UIntType::get(arg.getContext(), 32);
 }
 
 FIRRTLType AsSIntPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                              Optional<Location> loc) {
+                                              std::optional<Location> loc) {
   auto base = input.dyn_cast<FIRRTLBaseType>();
   if (!base) {
     if (loc)
@@ -2928,7 +2929,7 @@ FIRRTLType AsSIntPrimOp::inferUnaryReturnType(FIRRTLType input,
 }
 
 FIRRTLType AsUIntPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                              Optional<Location> loc) {
+                                              std::optional<Location> loc) {
   auto base = input.dyn_cast<FIRRTLBaseType>();
   if (!base) {
     if (loc)
@@ -2944,8 +2945,9 @@ FIRRTLType AsUIntPrimOp::inferUnaryReturnType(FIRRTLType input,
   return UIntType::get(input.getContext(), width);
 }
 
-FIRRTLType AsAsyncResetPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                                    Optional<Location> loc) {
+FIRRTLType
+AsAsyncResetPrimOp::inferUnaryReturnType(FIRRTLType input,
+                                         std::optional<Location> loc) {
   auto base = input.dyn_cast<FIRRTLBaseType>();
   if (!base) {
     if (loc)
@@ -2962,12 +2964,12 @@ FIRRTLType AsAsyncResetPrimOp::inferUnaryReturnType(FIRRTLType input,
 }
 
 FIRRTLType AsClockPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                               Optional<Location> loc) {
+                                               std::optional<Location> loc) {
   return ClockType::get(input.getContext());
 }
 
 FIRRTLType CvtPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                           Optional<Location> loc) {
+                                           std::optional<Location> loc) {
   if (auto uiType = input.dyn_cast<UIntType>()) {
     auto width = uiType.getWidthOrSentinel();
     if (width != -1)
@@ -2984,7 +2986,7 @@ FIRRTLType CvtPrimOp::inferUnaryReturnType(FIRRTLType input,
 }
 
 FIRRTLType NegPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                           Optional<Location> loc) {
+                                           std::optional<Location> loc) {
   auto inputi = input.dyn_cast<IntType>();
   if (!inputi) {
     if (loc)
@@ -2999,7 +3001,7 @@ FIRRTLType NegPrimOp::inferUnaryReturnType(FIRRTLType input,
 }
 
 FIRRTLType NotPrimOp::inferUnaryReturnType(FIRRTLType input,
-                                           Optional<Location> loc) {
+                                           std::optional<Location> loc) {
   auto inputi = input.dyn_cast<IntType>();
   if (!inputi) {
     if (loc)
@@ -3011,7 +3013,7 @@ FIRRTLType NotPrimOp::inferUnaryReturnType(FIRRTLType input,
 }
 
 FIRRTLType impl::inferReductionResult(FIRRTLType input,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   return UIntType::get(input.getContext(), 1);
 }
 
@@ -3031,7 +3033,7 @@ LogicalResult BitsPrimOp::validateArguments(ValueRange operands,
 
 FIRRTLType BitsPrimOp::inferReturnType(ValueRange operands,
                                        ArrayRef<NamedAttribute> attrs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto high = getAttr<IntegerAttr>(attrs, "hi").getValue().getSExtValue();
   auto low = getAttr<IntegerAttr>(attrs, "lo").getValue().getSExtValue();
@@ -3085,7 +3087,7 @@ LogicalResult impl::validateOneOperandOneConst(ValueRange operands,
 
 FIRRTLType HeadPrimOp::inferReturnType(ValueRange operands,
                                        ArrayRef<NamedAttribute> attrs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto amount = getAttr<IntegerAttr>(attrs, "amount").getValue().getSExtValue();
 
@@ -3129,7 +3131,7 @@ LogicalResult MuxPrimOp::validateArguments(ValueRange operands,
 /// - Bundles inferred in a pairwise fashion based on the field types.
 static FIRRTLBaseType inferMuxReturnType(FIRRTLBaseType high,
                                          FIRRTLBaseType low,
-                                         Optional<Location> loc) {
+                                         std::optional<Location> loc) {
   // If the types are identical we're done.
   if (high == low)
     return low;
@@ -3216,7 +3218,7 @@ static FIRRTLBaseType inferMuxReturnType(FIRRTLBaseType high,
 
 FIRRTLType MuxPrimOp::inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   auto highType = operands[1].getType().dyn_cast<FIRRTLBaseType>();
   auto lowType = operands[2].getType().dyn_cast<FIRRTLBaseType>();
   if (!highType || !lowType) {
@@ -3229,7 +3231,7 @@ FIRRTLType MuxPrimOp::inferReturnType(ValueRange operands,
 
 FIRRTLType PadPrimOp::inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto amount = getAttr<IntegerAttr>(attrs, "amount").getValue().getSExtValue();
 
@@ -3251,7 +3253,7 @@ FIRRTLType PadPrimOp::inferReturnType(ValueRange operands,
 
 FIRRTLType ShlPrimOp::inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto amount = getAttr<IntegerAttr>(attrs, "amount").getValue().getSExtValue();
 
@@ -3272,7 +3274,7 @@ FIRRTLType ShlPrimOp::inferReturnType(ValueRange operands,
 
 FIRRTLType ShrPrimOp::inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto amount = getAttr<IntegerAttr>(attrs, "amount").getValue().getSExtValue();
 
@@ -3293,7 +3295,7 @@ FIRRTLType ShrPrimOp::inferReturnType(ValueRange operands,
 
 FIRRTLType TailPrimOp::inferReturnType(ValueRange operands,
                                        ArrayRef<NamedAttribute> attrs,
-                                       Optional<Location> loc) {
+                                       std::optional<Location> loc) {
   auto input = operands[0].getType();
   auto amount = getAttr<IntegerAttr>(attrs, "amount").getValue().getSExtValue();
 
@@ -3325,14 +3327,14 @@ FIRRTLType TailPrimOp::inferReturnType(ValueRange operands,
 
 FIRRTLType IsXIntrinsicOp::inferReturnType(ValueRange operands,
                                            ArrayRef<NamedAttribute> attrs,
-                                           Optional<Location> loc) {
+                                           std::optional<Location> loc) {
   return UIntType::get(operands[0].getContext(), 1);
 }
 
 FIRRTLType
 PlusArgsTestIntrinsicOp::inferReturnType(ValueRange operands,
                                          ArrayRef<NamedAttribute> attrs,
-                                         Optional<Location> loc) {
+                                         std::optional<Location> loc) {
   return UIntType::get(attrs[0].getName().getContext(), 1);
 }
 
@@ -3788,7 +3790,7 @@ void XorRPrimOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
 
 FIRRTLType RefResolveOp::inferReturnType(ValueRange operands,
                                          ArrayRef<NamedAttribute> attrs,
-                                         Optional<Location> loc) {
+                                         std::optional<Location> loc) {
   auto inType = operands[0].getType();
   auto inRefType = inType.dyn_cast<RefType>();
   if (!inRefType) {
@@ -3802,7 +3804,7 @@ FIRRTLType RefResolveOp::inferReturnType(ValueRange operands,
 
 FIRRTLType RefSendOp::inferReturnType(ValueRange operands,
                                       ArrayRef<NamedAttribute> attrs,
-                                      Optional<Location> loc) {
+                                      std::optional<Location> loc) {
   auto inType = operands[0].getType();
   auto inBaseType = inType.dyn_cast<FIRRTLBaseType>();
   if (!inBaseType) {
@@ -3828,7 +3830,7 @@ void RefSubOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
 
 FIRRTLType RefSubOp::inferReturnType(ValueRange operands,
                                      ArrayRef<NamedAttribute> attrs,
-                                     Optional<Location> loc) {
+                                     std::optional<Location> loc) {
   auto inType = operands[0].getType().cast<RefType>().getType();
   auto fieldIdx =
       getAttr<IntegerAttr>(attrs, "index").getValue().getZExtValue();
diff --git a/lib/Dialect/FIRRTL/Import/FIRParser.cpp b/lib/Dialect/FIRRTL/Import/FIRParser.cpp
index c4547eea3..aca0479c8 100644
--- a/lib/Dialect/FIRRTL/Import/FIRParser.cpp
+++ b/lib/Dialect/FIRRTL/Import/FIRParser.cpp
@@ -370,7 +370,7 @@ ParseResult FIRParser::parseOptionalInfoLocator(LocationAttr &result) {
     return success();
 
   // Otherwise, set the location attribute and return.
-  result = locationPair.second.value();
+  result = *locationPair.second;
   return success();
 }
 
@@ -3163,7 +3163,7 @@ ParseResult FIRCircuitParser::parseCircuit(
 
   if (!indent.has_value())
     return emitError("'circuit' must be first token on its line"), failure();
-  unsigned circuitIndent = indent.value();
+  unsigned circuitIndent = *indent;
 
   LocWithInfo info(getToken().getLoc(), this);
   StringAttr name;
@@ -3247,7 +3247,7 @@ ParseResult FIRCircuitParser::parseCircuit(
       auto indent = getIndentation();
       if (!indent.has_value())
         return emitError("'module' must be first token on its line"), failure();
-      unsigned moduleIndent = indent.value();
+      unsigned moduleIndent = *indent;
 
       if (moduleIndent <= circuitIndent)
         return emitError("module should be indented more"), failure();
diff --git a/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt b/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
index 357d72369..cfa92186e 100755
--- a/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
+++ b/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
@@ -10,7 +10,6 @@ add_circt_dialect_library(CIRCTFIRRTLTransforms
   ExtractInstances.cpp
   FlattenMemory.cpp
   GrandCentral.cpp
-  GrandCentralTaps.cpp
   GrandCentralSignalMappings.cpp
   IMConstProp.cpp
   IMDeadCodeElim.cpp
diff --git a/lib/Dialect/FIRRTL/Transforms/EmitOMIR.cpp b/lib/Dialect/FIRRTL/Transforms/EmitOMIR.cpp
index 32356cb7c..8389185e7 100644
--- a/lib/Dialect/FIRRTL/Transforms/EmitOMIR.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/EmitOMIR.cpp
@@ -377,7 +377,7 @@ scatterOMField(Attribute original, const Attribute root, unsigned index,
                             fileLineColLocCache, ctx);
   mlir::LocationAttr infoLoc;
   if (maybeLoc.first)
-    infoLoc = maybeLoc.second.value();
+    infoLoc = *maybeLoc.second;
   else
     infoLoc = UnknownLoc::get(ctx);
 
@@ -445,7 +445,7 @@ scatterOMNode(Attribute original, const Attribute root, ApplyState &state) {
                             fileLineColLocCache, ctx);
   mlir::LocationAttr infoLoc;
   if (maybeLoc.first)
-    infoLoc = maybeLoc.second.value();
+    infoLoc = *maybeLoc.second;
   else
     infoLoc = UnknownLoc::get(ctx);
 
diff --git a/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp b/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
index 545f124f7..cd4d29304 100644
--- a/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
@@ -422,7 +422,7 @@ public:
 //===----------------------------------------------------------------------===//
 
 /// This extends the LastConnectVisitor to handle all Simulation related
-/// constructs which do not neet any processing at the module scope, but need to
+/// constructs which do not need any processing at the module scope, but need to
 /// be processed inside of a WhenOp.
 namespace {
 class WhenOpVisitor : public LastConnectResolver<WhenOpVisitor> {
@@ -526,7 +526,7 @@ void LastConnectResolver<ConcreteT>::processWhenOp(WhenOp whenOp,
   // Process the `else` block.
   DriverMap elseScope;
   if (whenOp.hasElseRegion()) {
-    // Else condition is the compliment of the then condition.
+    // Else condition is the complement of the then condition.
     auto elseCondition =
         b.createOrFold<NotPrimOp>(loc, condition.getType(), condition);
     // Conjoin the when condition with the outer condition.
diff --git a/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp b/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
index f1bf44b62..cb0c5e55f 100644
--- a/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
@@ -73,7 +73,7 @@ struct FlattenMemoryPass : public FlattenMemoryBase<FlattenMemoryPass> {
       // Get the width of individual aggregate leaf elements.
       for (auto f : flatMemType) {
         LLVM_DEBUG(llvm::dbgs() << "\n field type:" << f);
-        auto w = f.getWidth().value();
+        auto w = *f.getWidth();
         memWidths.push_back(w);
         memFlatWidth += w;
       }
@@ -152,8 +152,8 @@ struct FlattenMemoryPass : public FlattenMemoryBase<FlattenMemoryPass> {
             auto oldFieldBitWidth = getBitWidth(oldField.getType());
             // Following condition is true, if a data field is 0 bits. Then
             // newFieldType is of smaller bits than old.
-            if (getBitWidth(newFieldType) != oldFieldBitWidth.value())
-              newFieldType = UIntType::get(context, oldFieldBitWidth.value());
+            if (getBitWidth(newFieldType) != *oldFieldBitWidth)
+              newFieldType = UIntType::get(context, *oldFieldBitWidth);
             realOldField = builder.create<BitCastOp>(newFieldType, oldField);
             // Mask bits require special handling, since some of the mask bits
             // need to be repeated, direct bitcasting wouldn't work. Depending
diff --git a/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp b/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
index 8d8187fd9..39901a188 100644
--- a/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
@@ -1411,7 +1411,7 @@ Optional<TypeSum> GrandCentralPass::computeField(
             auto elements = vector.getElements();
             auto firstElement = fromAttr(elements[0]);
             auto elementType =
-                computeField(firstElement.value(), id, prefix,
+                computeField(*firstElement, id, prefix,
                              path.snapshot().append("[" + Twine(0) + "]"),
                              xmrElems, interfaceBuilder);
             if (!elementType)
@@ -1499,7 +1499,7 @@ Optional<StringAttr> GrandCentralPass::traverseBundle(
     StringAttr description =
         element.cast<DictionaryAttr>().getAs<StringAttr>("description");
     interfaceBuilder[lastIndex].elementsList.emplace_back(description, name,
-                                                          elementType.value());
+                                                          *elementType);
   }
   return iFaceName;
 }
diff --git a/lib/Dialect/FIRRTL/Transforms/GrandCentralTaps.cpp b/lib/Dialect/FIRRTL/Transforms/GrandCentralTaps.cpp
deleted file mode 100644
index e8d1f4ffc..000000000
--- a/lib/Dialect/FIRRTL/Transforms/GrandCentralTaps.cpp
+++ /dev/null
@@ -1,1594 +0,0 @@
-//===- GrandCentralTaps.cpp -------------------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the GrandCentralTaps pass.
-//
-//===----------------------------------------------------------------------===//
-
-#include "PassDetails.h"
-#include "circt/Dialect/FIRRTL/AnnotationDetails.h"
-#include "circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h"
-#include "circt/Dialect/FIRRTL/FIRRTLAnnotations.h"
-#include "circt/Dialect/FIRRTL/FIRRTLInstanceGraph.h"
-#include "circt/Dialect/FIRRTL/FIRRTLOps.h"
-#include "circt/Dialect/FIRRTL/FIRRTLTypes.h"
-#include "circt/Dialect/FIRRTL/FIRRTLUtils.h"
-#include "circt/Dialect/FIRRTL/FIRRTLVisitors.h"
-#include "circt/Dialect/FIRRTL/Namespace.h"
-#include "circt/Dialect/FIRRTL/Passes.h"
-#include "circt/Dialect/HW/HWAttributes.h"
-#include "circt/Dialect/HW/HWOps.h"
-#include "circt/Dialect/HW/HWSymCache.h"
-#include "circt/Dialect/HW/InstanceGraphBase.h"
-#include "circt/Dialect/SV/SVOps.h"
-#include "mlir/IR/ImplicitLocOpBuilder.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/TinyPtrVector.h"
-#include "llvm/Support/Allocator.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/FormatVariadic.h"
-
-#define DEBUG_TYPE "gct"
-
-using namespace circt;
-using namespace firrtl;
-using hw::HWInstanceLike;
-using hw::InnerRefAttr;
-using hw::InstancePath;
-using mlir::FailureOr;
-
-//===----------------------------------------------------------------------===//
-// PointerLikeTypeTraits
-//===----------------------------------------------------------------------===//
-
-namespace llvm {
-template <>
-struct PointerLikeTypeTraits<InstanceOp> : PointerLikeTypeTraits<Operation *> {
-public:
-  static inline void *getAsVoidPointer(InstanceOp val) {
-    return const_cast<void *>(val.getAsOpaquePointer());
-  }
-  static inline InstanceOp getFromVoidPointer(void *p) {
-    return InstanceOp::getFromOpaquePointer(p);
-  }
-};
-} // end namespace llvm
-
-//===----------------------------------------------------------------------===//
-// Utilities
-//===----------------------------------------------------------------------===//
-
-namespace {
-
-/// A port annotated with a data tap key or mem tap.
-struct AnnotatedPort {
-  unsigned portNum;
-  Annotation anno;
-};
-
-/// An extmodule that has annotated ports.
-struct AnnotatedExtModule {
-  FExtModuleOp extModule;
-  SmallVector<AnnotatedPort, 4> portAnnos;
-  // Module annotations without data tap stuff.
-  ArrayAttr filteredModuleAnnos;
-  /// Port annotations without data tap stuff.
-  SmallVector<AnnotationSet, 8> filteredPortAnnos;
-};
-
-/// A value annotated to be tapped.
-struct TappedValue {
-  Value value;
-  Annotation anno;
-};
-
-/// A parsed integer literal.
-struct Literal {
-  IntegerAttr value;
-  FIRRTLType type;
-  operator bool() const { return value && type; }
-};
-
-/// Necessary information to wire up a port with tapped data or memory location.
-struct PortWiring {
-  using Target = hw::HWSymbolCache::Item;
-
-  unsigned portNum;
-  /// The different instance paths that lead to this port. If the NLA field is
-  /// set, these are the different instance paths to the root of the NLA path.
-  ArrayRef<InstancePath> prefices;
-  /// The operation or module port being wire to this data tap module port.
-  Target target;
-  /// The fieldID which specifies the element we want to connect in the port.
-  unsigned targetFieldID;
-  /// An additional string suffix to append to the hierarchical name.
-  SmallString<16> suffix;
-  /// If set, the port should output a constant literal.
-  Literal literal;
-  /// The non-local anchor further specifying where to connect.
-  hw::HierPathOp nla;
-  /// True if the tapped target is known to be zero-width.  This indicates that
-  /// the port should not be wired.  The port will be removed by LowerToHW.
-  bool zeroWidth = false;
-
-  PortWiring() : target(nullptr) {}
-};
-
-} // namespace
-
-/// Return a version of `path` that skips all front instances it has in common
-/// with `other`.
-static InstancePath stripCommonPrefix(InstancePath path, InstancePath other) {
-  while (!path.empty() && !other.empty() && path.front() == other.front()) {
-    path = path.drop_front();
-    other = other.drop_front();
-  }
-  return path;
-}
-
-/// A reference data tap key, identified by the annotation id and port id.
-using Key = std::pair<Attribute, Attribute>;
-
-/// A tapped port, described as the module/extmodule operation and the port
-/// number.
-struct Port : std::pair<Operation *, unsigned> {
-  using std::pair<Operation *, unsigned>::pair;
-  operator bool() const { return bool(first); }
-};
-
-// Allow printing of `Key` through `<<`.
-template <typename T>
-static T &operator<<(T &os, Key key) {
-  return os << "[" << key.first << ", " << key.second << "]";
-}
-
-/// Map an annotation to a `Key`.
-static Key getKey(Annotation anno) {
-  auto id = anno.getMember("id");
-  auto portID = anno.getMember("portID");
-  return {id, portID};
-}
-
-/// Parse a FIRRTL `UInt`/`SInt` literal.
-static FailureOr<Literal> parseIntegerLiteral(MLIRContext *context,
-                                              StringRef literal, Location loc) {
-  auto initial = literal; // used for error reporting
-  auto consumed = [&]() {
-    return initial.take_front(initial.size() - literal.size());
-  };
-  auto bail = [&](const Twine &message) {
-    mlir::emitError(loc, "expected ")
-        << message << " in literal after `" << consumed() << "`";
-    return failure();
-  };
-  auto consume = [&](StringRef text) {
-    if (!literal.consume_front(text)) {
-      (void)bail(Twine("`") + text + "`");
-      return false;
-    }
-    return true;
-  };
-
-  // Parse the leading keyword.
-  bool isSigned;
-  if (literal.consume_front("UInt")) {
-    isSigned = false;
-  } else if (literal.consume_front("SInt")) {
-    isSigned = true;
-  } else {
-    mlir::emitError(loc, "expected leading `UInt` or `SInt` in literal");
-    return failure();
-  }
-
-  // Parse the optional width.
-  Optional<APInt> width = {};
-  if (literal.consume_front("<")) {
-    auto widthLiteral = literal.take_while(llvm::isDigit);
-    APInt parsedWidth;
-    if (widthLiteral.getAsInteger(10, parsedWidth))
-      return bail("integer width");
-    literal = literal.drop_front(widthLiteral.size());
-    if (!literal.consume_front(">"))
-      return bail("closing `>`");
-    width = parsedWidth;
-  }
-
-  // Parse the opening parenthesis.
-  if (!consume("("))
-    return failure();
-
-  // Parse the opening quotes and base specifier.
-  unsigned base = 10;
-  bool hasQuotes = false;
-  if (literal.consume_front("\"")) {
-    hasQuotes = true;
-    if (literal.consume_front("h"))
-      base = 16;
-    else if (literal.consume_front("o"))
-      base = 8;
-    else if (literal.consume_front("b"))
-      base = 2;
-    else
-      return bail("base specifier (`h`, `o`, or `b`)");
-  }
-
-  // Parse the optional sign.
-  bool isNegative = false;
-  if (literal.consume_front("-"))
-    isNegative = true;
-  else if (literal.consume_front("+"))
-    isNegative = false;
-
-  // Parse the actual value.
-  APInt parsedValue;
-  auto valueLiteral = literal.take_while(llvm::isHexDigit);
-  if (valueLiteral.getAsInteger(base, parsedValue))
-    return bail("integer value");
-  literal = literal.drop_front(valueLiteral.size());
-
-  // Parse the closing quotes.
-  if (hasQuotes && !literal.consume_front("\""))
-    return bail("closing quotes");
-
-  // Parse the closing parenthesis.
-  if (!consume(")"))
-    return failure();
-
-  // Ensure that there's no junk afterwards.
-  if (!literal.empty()) {
-    mlir::emitError(loc, "extraneous `")
-        << literal << "` in literal after `" << consumed() << "`";
-    return failure();
-  }
-
-  // Ensure we have a 0 bit at the top to properly hold a negative value.
-  if (parsedValue.isNegative())
-    parsedValue = parsedValue.zext(parsedValue.getBitWidth() + 1);
-  if (isNegative)
-    parsedValue = -parsedValue;
-
-  // Ensure the width is sound.
-  int32_t saneWidth = -1;
-  if (width) {
-    saneWidth = (int32_t)width->getLimitedValue(INT32_MAX);
-    if (saneWidth != *width) {
-      mlir::emitError(loc, "width of literal `")
-          << initial << "` is too big to handle";
-      return failure();
-    }
-    parsedValue = isSigned ? parsedValue.sextOrTrunc(saneWidth)
-                           : parsedValue.zextOrTrunc(saneWidth);
-  }
-
-  // Assemble the literal.
-  Literal lit;
-  lit.type = IntType::get(context, isSigned, saneWidth);
-  lit.value = IntegerAttr::get(
-      IntegerType::get(context, parsedValue.getBitWidth(),
-                       isSigned ? IntegerType::Signed : IntegerType::Unsigned),
-      parsedValue);
-  return lit;
-}
-
-Value lowerInternalPathAnno(AnnoPathValue &srcTarget,
-                            const AnnoPathValue &moduleTarget,
-                            const AnnoPathValue &target,
-                            StringAttr internalPathAttr, FIRRTLType targetType,
-                            ApplyState &state) {
-  Value sendVal;
-  FModuleLike mod = cast<FModuleLike>(moduleTarget.ref.getOp());
-  InstanceOp modInstance;
-  if (!moduleTarget.instances.empty()) {
-    modInstance = moduleTarget.instances.back();
-  } else {
-    auto *node = state.instancePathCache.instanceGraph.lookup(
-        cast<hw::HWModuleLike>((Operation *)mod));
-    if (!node->hasOneUse()) {
-      mod->emitOpError(
-          "cannot be used for DataTaps, it is instantiated multiple times");
-      return nullptr;
-    }
-    modInstance = cast<InstanceOp>((*node->uses().begin())->getInstance());
-  }
-  ImplicitLocOpBuilder builder(modInstance.getLoc(), modInstance);
-  builder.setInsertionPointAfter(modInstance);
-  auto portRefType = RefType::get(targetType.cast<FIRRTLBaseType>());
-  SmallString<32> refName;
-  for (auto c : internalPathAttr.getValue()) {
-    switch (c) {
-    case '.':
-    case '[':
-      refName.push_back('_');
-      break;
-    case ']':
-      break;
-    default:
-      refName.push_back(c);
-      break;
-    }
-  }
-
-  // Add RefType ports corresponding to this "internalPath" to the external
-  // module. This also updates all the instances of the external module.
-  // This removes and replaces the instance, and returns the updated
-  // instance.
-  modInstance = addPortsToModule(
-      mod, modInstance, portRefType, Direction::Out, refName,
-      state.instancePathCache,
-      [&](FModuleLike mod) -> ModuleNamespace & {
-        return state.getNamespace(mod);
-      },
-      &state.targetCaches);
-  // Since the instance op generates the RefType output, no need of another
-  // RefSendOp.  Store into an op to ensure we have stable reference,
-  // so future tapping won't invalidate this Value.
-  sendVal = modInstance.getResults().back();
-  sendVal =
-      builder
-          .create<mlir::UnrealizedConversionCastOp>(sendVal.getType(), sendVal)
-          ->getResult(0);
-
-  // Now set the instance as the source for the final datatap xmr.
-  srcTarget = AnnoPathValue(modInstance);
-  if (auto extMod = dyn_cast<FExtModuleOp>((Operation *)mod)) {
-    // The extern module can have other internal paths attached to it,
-    // append this to them.
-    SmallVector<Attribute> paths(extMod.getInternalPathsAttr().getValue());
-    paths.push_back(internalPathAttr);
-    extMod.setInternalPathsAttr(builder.getArrayAttr(paths));
-  } else if (auto intMod = dyn_cast<FModuleOp>((Operation *)mod)) {
-    auto builder = ImplicitLocOpBuilder::atBlockEnd(
-        intMod.getLoc(), &intMod.getBody().getBlocks().back());
-    auto pathStr = builder.create<VerbatimExprOp>(
-        portRefType.getType(), internalPathAttr.getValue(), ValueRange{});
-    auto sendPath = builder.create<RefSendOp>(pathStr);
-    builder.create<StrictConnectOp>(intMod.getArguments().back(),
-                                    sendPath.getResult());
-  }
-
-  if (!moduleTarget.instances.empty())
-    srcTarget.instances = moduleTarget.instances;
-  else {
-    auto path = state.instancePathCache
-                    .getAbsolutePaths(modInstance->getParentOfType<FModuleOp>())
-                    .back();
-    srcTarget.instances.append(path.begin(), path.end());
-  }
-  return sendVal;
-}
-
-LogicalResult static applyNoBlackBoxStyleDataTaps(const AnnoPathValue &target,
-                                                  DictionaryAttr anno,
-                                                  ApplyState &state) {
-  auto *context = state.circuit.getContext();
-  auto loc = state.circuit.getLoc();
-
-  // Process all the taps.
-  auto keyAttr = tryGetAs<ArrayAttr>(anno, anno, "keys", loc, dataTapsClass);
-  if (!keyAttr)
-    return failure();
-  for (size_t i = 0, e = keyAttr.size(); i != e; ++i) {
-    auto b = keyAttr[i];
-    auto path = ("keys[" + Twine(i) + "]").str();
-    auto bDict = b.cast<DictionaryAttr>();
-    auto classAttr =
-        tryGetAs<StringAttr>(bDict, anno, "class", loc, dataTapsClass, path);
-    if (!classAttr)
-      return failure();
-    // Can only handle ReferenceDataTapKey and DataTapModuleSignalKey
-    if (classAttr.getValue() != referenceKeyClass &&
-        classAttr.getValue() != internalKeyClass)
-      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
-                                      "' with path '" +
-                                      (Twine(path) + ".class") +
-                                      "' contained an unknown/unimplemented "
-                                      "DataTapKey class '" +
-                                      classAttr.getValue() + "'.")
-                 .attachNote()
-             << "The full Annotation is reproduced here: " << anno << "\n";
-
-    auto sinkNameAttr =
-        tryGetAs<StringAttr>(bDict, anno, "sink", loc, dataTapsClass, path);
-    std::string wirePathStr;
-    if (sinkNameAttr)
-      wirePathStr = canonicalizeTarget(sinkNameAttr.getValue());
-    if (!wirePathStr.empty())
-      if (!tokenizePath(wirePathStr))
-        wirePathStr.clear();
-    Optional<AnnoPathValue> wireTarget = std::nullopt;
-    if (!wirePathStr.empty())
-      wireTarget = resolvePath(wirePathStr, state.circuit, state.symTbl,
-                               state.targetCaches);
-    if (!wireTarget)
-      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
-                                      "' with wire path '" + wirePathStr +
-                                      "' couldnot be resolved.");
-    if (!wireTarget->ref.getImpl().isOp())
-      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
-                                      "' with path '" +
-                                      (Twine(path) + ".class") +
-                                      "' cannot specify a port for sink.");
-    // Extract the name of the wire, used for datatap.
-    auto tapName = StringAttr::get(
-        context, wirePathStr.substr(wirePathStr.find_last_of('>') + 1));
-    Optional<AnnoPathValue> srcTarget = std::nullopt;
-    Value sendVal;
-    if (classAttr.getValue() == internalKeyClass) {
-      // For DataTapModuleSignalKey, the source is encoded as a string, that
-      // should exist inside the specified module. This source string is used as
-      // a suffix to the instance name for the module inside a VerbatimExprOp.
-      // This verbatim represents an intermediate xmr, which is then used by a
-      // ref.send to be read remotely.
-      auto internalPathAttr = tryGetAs<StringAttr>(bDict, anno, "internalPath",
-                                                   loc, dataTapsClass, path);
-      auto moduleAttr =
-          tryGetAs<StringAttr>(bDict, anno, "module", loc, dataTapsClass, path);
-      if (!internalPathAttr || !moduleAttr)
-        return failure();
-      auto moduleTargetStr = canonicalizeTarget(moduleAttr.getValue());
-      if (!tokenizePath(moduleTargetStr))
-        return failure();
-      Optional<AnnoPathValue> moduleTarget = resolvePath(
-          moduleTargetStr, state.circuit, state.symTbl, state.targetCaches);
-      if (!moduleTarget)
-        return failure();
-      AnnoPathValue internalPathSrc;
-      auto targetType = wireTarget->ref.getType().cast<FIRRTLBaseType>();
-      if (wireTarget->fieldIdx)
-        targetType = targetType.getFinalTypeByFieldID(wireTarget->fieldIdx);
-      sendVal = lowerInternalPathAnno(internalPathSrc, *moduleTarget, target,
-                                      internalPathAttr, targetType, state);
-      if (!sendVal)
-        return failure();
-      srcTarget = internalPathSrc;
-    } else {
-      // Now handle ReferenceDataTapKey. Get the source from annotation.
-      auto sourceAttr =
-          tryGetAs<StringAttr>(bDict, anno, "source", loc, dataTapsClass, path);
-      if (!sourceAttr)
-        return failure();
-      auto sourcePathStr = canonicalizeTarget(sourceAttr.getValue());
-      if (!tokenizePath(sourcePathStr))
-        return failure();
-      LLVM_DEBUG(llvm::dbgs() << "\n Drill xmr path from :" << sourcePathStr
-                              << " to " << wirePathStr);
-      srcTarget = resolvePath(sourcePathStr, state.circuit, state.symTbl,
-                              state.targetCaches);
-    }
-    if (!srcTarget)
-      return mlir::emitError(loc, "Annotation '" + Twine(dataTapsClass) +
-                                      "' source path couldnot be resolved.");
-
-    auto wireModule =
-        cast<FModuleOp>(wireTarget->ref.getModule().getOperation());
-
-    if (auto extMod = dyn_cast<FExtModuleOp>(srcTarget->ref.getOp())) {
-      // If the source is a port on extern module, then move the source to the
-      // instance port for the ext module.
-      auto portNo = srcTarget->ref.getImpl().getPortNo();
-      auto lastInst = srcTarget->instances.pop_back_val();
-      auto builder = ImplicitLocOpBuilder::atBlockEnd(lastInst.getLoc(),
-                                                      lastInst->getBlock());
-      builder.setInsertionPointAfter(lastInst);
-      // Instance port cannot be used as an annotation target, so use a NodeOp.
-      auto node = builder.create<NodeOp>(lastInst.getType(portNo),
-                                         lastInst.getResult(portNo));
-      AnnotationSet::addDontTouch(node);
-      srcTarget->ref = AnnoTarget(circt::firrtl::detail::AnnoTargetImpl(node));
-    }
-
-    // The RefSend value can be either generated by the instance of an external
-    // module or a RefSendOp.
-    if (!sendVal) {
-      auto srcModule =
-          dyn_cast<FModuleOp>(srcTarget->ref.getModule().getOperation());
-
-      ImplicitLocOpBuilder sendBuilder(srcModule.getLoc(), srcModule);
-      // Set the insertion point for the RefSend, it should be dominated by the
-      // srcTarget value. If srcTarget is a port, then insert the RefSend
-      // at the beggining of the module, else define the RefSend at the end of
-      // the block that contains the srcTarget Op.
-      if (srcTarget->ref.getImpl().isOp()) {
-        sendVal = srcTarget->ref.getImpl().getOp()->getResult(0);
-        sendBuilder.setInsertionPointAfter(srcTarget->ref.getOp());
-      } else if (srcTarget->ref.getImpl().isPort()) {
-        sendVal = srcModule.getArgument(srcTarget->ref.getImpl().getPortNo());
-        sendBuilder.setInsertionPointToStart(srcModule.getBodyBlock());
-      }
-      // If the target value is a field of an aggregate create the
-      // subfield/subaccess into it.
-      sendVal = getValueByFieldID(sendBuilder, sendVal, srcTarget->fieldIdx);
-      // Note: No DontTouch added to sendVal, it can be constantprop'ed or
-      // CSE'ed.
-    }
-
-    auto *targetOp = wireTarget->ref.getOp();
-    auto sinkBuilder = ImplicitLocOpBuilder::atBlockEnd(wireModule.getLoc(),
-                                                        targetOp->getBlock());
-    auto wireType = cast<FIRRTLBaseType>(targetOp->getResult(0).getType());
-    // Get type of sent value, if already a RefType, the base type.
-    auto valType = getBaseType(cast<FIRRTLType>(sendVal.getType()));
-    Value sink = getValueByFieldID(sinkBuilder, targetOp->getResult(0),
-                                   wireTarget->fieldIdx);
-
-    // For resets, sometimes inject a cast between sink and target 'sink'.
-    // Introduced a dummy wire and cast that, dummy wire will be 'sink'.
-    if (valType.isResetType() &&
-        valType.getWidthlessType() != wireType.getWidthlessType()) {
-      // Helper: create a wire, cast it with callback, connect cast to sink.
-      auto addWireWithCast = [&](auto createCast) {
-        auto wire = sinkBuilder.create<WireOp>(
-            valType,
-            state.getNamespace(wireModule).newName(tapName.getValue()));
-        sinkBuilder.create<ConnectOp>(sink, createCast(wire));
-        sink = wire;
-      };
-      if (isa<IntType>(wireType))
-        addWireWithCast([&](auto v) {
-          return sinkBuilder.create<AsUIntPrimOp>(wireType, v);
-        });
-      else if (isa<AsyncResetType>(wireType))
-        addWireWithCast(
-            [&](auto v) { return sinkBuilder.create<AsAsyncResetPrimOp>(v); });
-    }
-
-    state.wiringProblems.push_back({sendVal, sink, ""});
-  }
-
-  return success();
-}
-
-//===----------------------------------------------------------------------===//
-// Code related to handling Grand Central Data/Mem Taps annotations
-//===----------------------------------------------------------------------===//
-
-// Describes tap points into the design.  This has the following structure:
-//   blackBox: ModuleTarget
-//   keys: Seq[DataTapKey]
-// DataTapKey has multiple implementations:
-//   - ReferenceDataTapKey: (tapping a point which exists in the FIRRTL)
-//       portName: ReferenceTarget
-//       source: ReferenceTarget
-//   - DataTapModuleSignalKey: (tapping a point, by name, in a blackbox)
-//       portName: ReferenceTarget
-//       module: IsModule
-//       internalPath: String
-//   - DeletedDataTapKey: (not implemented here)
-//       portName: ReferenceTarget
-//   - LiteralDataTapKey: (not implemented here)
-//       portName: ReferenceTarget
-//       literal: Literal
-// A Literal is a FIRRTL IR literal serialized to a string.  For now, just
-// store the string.
-// TODO: Parse the literal string into a UInt or SInt literal.
-LogicalResult circt::firrtl::applyGCTDataTaps(const AnnoPathValue &target,
-                                              DictionaryAttr anno,
-                                              ApplyState &state) {
-
-  auto *context = state.circuit.getContext();
-  auto loc = state.circuit.getLoc();
-
-  auto id = state.newID();
-  NamedAttrList attrs;
-  attrs.append("class", StringAttr::get(context, dataTapsBlackboxClass));
-  // The new DataTaps donot have blackbox field. Lower them directly to RefType.
-  if (!anno.contains("blackBox"))
-    return applyNoBlackBoxStyleDataTaps(target, anno, state);
-  auto blackBoxAttr =
-      tryGetAs<StringAttr>(anno, anno, "blackBox", loc, dataTapsClass);
-  if (!blackBoxAttr)
-    return failure();
-  auto canonicalTarget = canonicalizeTarget(blackBoxAttr.getValue());
-  if (!tokenizePath(canonicalTarget))
-    return failure();
-  attrs.append("target", StringAttr::get(context, canonicalTarget));
-  state.addToWorklistFn(DictionaryAttr::getWithSorted(context, attrs));
-
-  // Process all the taps.
-  auto keyAttr = tryGetAs<ArrayAttr>(anno, anno, "keys", loc, dataTapsClass);
-  if (!keyAttr)
-    return failure();
-  for (size_t i = 0, e = keyAttr.size(); i != e; ++i) {
-    auto b = keyAttr[i];
-    auto path = ("keys[" + Twine(i) + "]").str();
-    auto bDict = b.cast<DictionaryAttr>();
-    auto classAttr =
-        tryGetAs<StringAttr>(bDict, anno, "class", loc, dataTapsClass, path);
-    if (!classAttr)
-      return failure();
-
-    // The "portName" field is common across all sub-types of DataTapKey.
-    NamedAttrList port;
-    auto portNameAttr =
-        tryGetAs<StringAttr>(bDict, anno, "portName", loc, dataTapsClass, path);
-    if (!portNameAttr)
-      return failure();
-    auto portTarget = canonicalizeTarget(portNameAttr.getValue());
-    if (!tokenizePath(portTarget))
-      return failure();
-
-    if (classAttr.getValue() == referenceKeyClass) {
-      NamedAttrList source;
-      auto portID = state.newID();
-      source.append("class", StringAttr::get(context, referenceKeySourceClass));
-      source.append("id", id);
-      source.append("portID", portID);
-      auto sourceAttr =
-          tryGetAs<StringAttr>(bDict, anno, "source", loc, dataTapsClass, path);
-      if (!sourceAttr)
-        return failure();
-      auto sourceTarget = canonicalizeTarget(sourceAttr.getValue());
-      if (!tokenizePath(sourceTarget))
-        return failure();
-
-      source.append("target", StringAttr::get(context, sourceTarget));
-
-      state.addToWorklistFn(DictionaryAttr::get(context, source));
-
-      // Annotate the data tap module port.
-      port.append("class", StringAttr::get(context, referenceKeyPortClass));
-      port.append("id", id);
-      port.append("portID", portID);
-      port.append("target", StringAttr::get(context, portTarget));
-      state.addToWorklistFn(DictionaryAttr::getWithSorted(context, port));
-      continue;
-    }
-
-    if (classAttr.getValue() == internalKeyClass) {
-      NamedAttrList module;
-      auto portID = state.newID();
-      module.append("class", StringAttr::get(context, internalKeySourceClass));
-      module.append("id", id);
-      auto internalPathAttr = tryGetAs<StringAttr>(bDict, anno, "internalPath",
-                                                   loc, dataTapsClass, path);
-      auto moduleAttr =
-          tryGetAs<StringAttr>(bDict, anno, "module", loc, dataTapsClass, path);
-      if (!internalPathAttr || !moduleAttr)
-        return failure();
-      module.append("internalPath", internalPathAttr);
-      module.append("portID", portID);
-      auto moduleTarget = canonicalizeTarget(moduleAttr.getValue());
-      if (!tokenizePath(moduleTarget))
-        return failure();
-
-      module.append("target", StringAttr::get(context, moduleTarget));
-      state.addToWorklistFn(DictionaryAttr::getWithSorted(context, module));
-
-      // Annotate the data tap module port.
-      port.append("class", StringAttr::get(context, internalKeyPortClass));
-      port.append("id", id);
-      port.append("portID", portID);
-      port.append("target", StringAttr::get(context, portTarget));
-      state.addToWorklistFn(DictionaryAttr::get(context, port));
-      continue;
-    }
-
-    if (classAttr.getValue() == deletedKeyClass) {
-      // Annotate the data tap module port.
-      port.append("class", classAttr);
-      port.append("id", id);
-      port.append("target", StringAttr::get(context, portTarget));
-      state.addToWorklistFn(DictionaryAttr::get(context, port));
-      continue;
-    }
-
-    if (classAttr.getValue() == literalKeyClass) {
-      auto literalAttr = tryGetAs<StringAttr>(bDict, anno, "literal", loc,
-                                              dataTapsClass, path);
-      if (!literalAttr)
-        return failure();
-
-      // Annotate the data tap module port.
-      port.append("class", classAttr);
-      port.append("id", id);
-      port.append("literal", literalAttr);
-      port.append("target", StringAttr::get(context, portTarget));
-      state.addToWorklistFn(DictionaryAttr::get(context, port));
-      continue;
-    }
-
-    mlir::emitError(
-        loc, "Annotation '" + Twine(dataTapsClass) + "' with path '" +
-                 (Twine(path) + ".class") +
-                 "' contained an unknown/unimplemented DataTapKey class '" +
-                 classAttr.getValue() + "'.")
-            .attachNote()
-        << "The full Annotation is reproduced here: " << anno << "\n";
-    return failure();
-  }
-
-  return success();
-}
-
-LogicalResult applyGCTMemTapsWithWires(const AnnoPathValue &target,
-                                       DictionaryAttr anno,
-                                       std::string &sourceTargetStr,
-                                       ApplyState &state) {
-  auto loc = state.circuit.getLoc();
-  Value memDbgPort;
-  Optional<AnnoPathValue> srcTarget = resolvePath(
-      sourceTargetStr, state.circuit, state.symTbl, state.targetCaches);
-  if (!srcTarget)
-    return mlir::emitError(loc, "cannot resolve source target path '")
-           << sourceTargetStr << "'";
-  auto tapsAttr = tryGetAs<ArrayAttr>(anno, anno, "sink", loc, memTapClass);
-  if (!tapsAttr || tapsAttr.empty())
-    return mlir::emitError(loc, "sink must have at least one entry");
-  if (auto combMem = dyn_cast<chirrtl::CombMemOp>(srcTarget->ref.getOp())) {
-    if (!combMem.getType().getElementType().isGround())
-      return combMem.emitOpError(
-          "cannot generate MemTap to a memory with aggregate data type");
-    ImplicitLocOpBuilder builder(combMem->getLoc(), combMem);
-    builder.setInsertionPointAfter(combMem);
-    // Construct the type for the debug port.
-    auto debugType =
-        RefType::get(FVectorType::get(combMem.getType().getElementType(),
-                                      combMem.getType().getNumElements()));
-
-    auto debugPort = builder.create<chirrtl::MemoryDebugPortOp>(
-        debugType, combMem,
-        state.getNamespace(srcTarget->ref.getModule()).newName("memTap"));
-
-    memDbgPort = debugPort.getResult();
-    if (srcTarget->instances.empty()) {
-      auto path = state.instancePathCache.getAbsolutePaths(
-          combMem->getParentOfType<FModuleOp>());
-      if (path.size() > 1)
-        return combMem.emitOpError(
-            "cannot be resolved as source for MemTap, multiple paths from top "
-            "exist and unique instance cannot be resolved");
-      srcTarget->instances.append(path.back().begin(), path.back().end());
-    }
-    if (tapsAttr.size() != combMem.getType().getNumElements())
-      return mlir::emitError(
-          loc, "sink cannot specify more taps than the depth of the memory");
-  } else
-    return srcTarget->ref.getOp()->emitOpError(
-        "unsupported operation, only CombMem can be used as the source of "
-        "MemTap");
-
-  auto tap = tapsAttr[0].dyn_cast_or_null<StringAttr>();
-  if (!tap) {
-    return mlir::emitError(
-               loc, "Annotation '" + Twine(memTapClass) +
-                        "' with path '.taps[0" +
-                        "]' contained an unexpected type (expected a string).")
-               .attachNote()
-           << "The full Annotation is reprodcued here: " << anno << "\n";
-  }
-  auto wireTargetStr = canonicalizeTarget(tap.getValue());
-  if (!tokenizePath(wireTargetStr))
-    return failure();
-  Optional<AnnoPathValue> wireTarget = resolvePath(
-      wireTargetStr, state.circuit, state.symTbl, state.targetCaches);
-  if (!wireTarget)
-    return mlir::emitError(loc, "Annotation '" + Twine(memTapClass) +
-                                    "' with path '.taps[0]' contains target '" +
-                                    wireTargetStr +
-                                    "' that cannot be resolved.")
-               .attachNote()
-           << "The full Annotation is reproduced here: " << anno << "\n";
-
-  auto sendVal = memDbgPort;
-  if (wireTarget->ref.getOp()->getResult(0).getType() !=
-      cast<RefType>(sendVal.getType()).getType())
-    return wireTarget->ref.getOp()->emitError(
-        "cannot generate the MemTap, wiretap Type does not match the memory "
-        "type");
-  auto sink = wireTarget->ref.getOp()->getResult(0);
-  state.wiringProblems.push_back({sendVal, sink, "memTap"});
-  return success();
-}
-
-LogicalResult circt::firrtl::applyGCTMemTaps(const AnnoPathValue &target,
-                                             DictionaryAttr anno,
-                                             ApplyState &state) {
-
-  auto *context = state.circuit.getContext();
-  auto loc = state.circuit.getLoc();
-
-  auto id = state.newID();
-  NamedAttrList attrs;
-  auto sourceAttr =
-      tryGetAs<StringAttr>(anno, anno, "source", loc, memTapClass);
-  if (!sourceAttr)
-    return failure();
-  auto sourceTarget = canonicalizeTarget(sourceAttr.getValue());
-  if (!tokenizePath(sourceTarget))
-    return failure();
-  attrs.append("class", StringAttr::get(context, memTapSourceClass));
-  attrs.append("id", id);
-  attrs.append("target", StringAttr::get(context, sourceTarget));
-
-  if (!anno.contains("taps"))
-    return applyGCTMemTapsWithWires(target, anno, sourceTarget, state);
-  auto tapsAttr = tryGetAs<ArrayAttr>(anno, anno, "taps", loc, memTapClass);
-  state.addToWorklistFn(DictionaryAttr::get(context, attrs));
-  StringSet<> memTapBlackboxes;
-  for (size_t i = 0, e = tapsAttr.size(); i != e; ++i) {
-    auto tap = tapsAttr[i].dyn_cast_or_null<StringAttr>();
-    if (!tap) {
-      mlir::emitError(
-          loc, "Annotation '" + Twine(memTapClass) + "' with path '.taps[" +
-                   Twine(i) +
-                   "]' contained an unexpected type (expected a string).")
-              .attachNote()
-          << "The full Annotation is reprodcued here: " << anno << "\n";
-      return failure();
-    }
-    NamedAttrList port;
-    port.append("class", StringAttr::get(context, memTapPortClass));
-    port.append("id", id);
-    port.append("portID", IntegerAttr::get(IntegerType::get(context, 64), i));
-    auto canonTarget = canonicalizeTarget(tap.getValue());
-    if (!tokenizePath(canonTarget))
-      return failure();
-    port.append("target", StringAttr::get(context, canonTarget));
-    state.addToWorklistFn(DictionaryAttr::get(context, port));
-
-    auto blackboxTarget = tokenizePath(canonTarget).value();
-    blackboxTarget.name = {};
-    blackboxTarget.component.clear();
-    auto blackboxTargetStr = blackboxTarget.str();
-    if (!memTapBlackboxes.insert(blackboxTargetStr).second)
-      continue;
-
-    NamedAttrList blackbox;
-    blackbox.append("class", StringAttr::get(context, memTapBlackboxClass));
-    blackbox.append("target", StringAttr::get(context, blackboxTargetStr));
-    state.addToWorklistFn(DictionaryAttr::getWithSorted(context, blackbox));
-  }
-
-  return success();
-}
-
-//===----------------------------------------------------------------------===//
-// Pass Infrastructure
-//===----------------------------------------------------------------------===//
-
-class GrandCentralTapsPass : public GrandCentralTapsBase<GrandCentralTapsPass> {
-  void runOnOperation() override;
-  void gatherAnnotations(Operation *op);
-  void processAnnotation(AnnotatedPort &portAnno, AnnotatedExtModule &blackBox,
-                         InstancePathCache &instancePaths);
-
-  // Helpers to simplify collecting taps on the various things.
-  void gatherTap(Annotation anno, Port port) {
-    auto key = getKey(anno);
-    annos.insert({key, anno});
-    assert(!tappedPorts.count(key) && "ambiguous tap annotation");
-    auto portType = cast<FModuleLike>(port.first).getPortType(port.second);
-    auto firrtlPortType = portType.dyn_cast<FIRRTLType>();
-    if (!firrtlPortType) {
-      port.first->emitError("data tap cannot target port with non-FIRRTL type ")
-          << portType;
-      return signalPassFailure();
-    }
-
-    auto portWidth =
-        firrtlPortType.cast<FIRRTLBaseType>().getBitWidthOrSentinel();
-    // If the port width is non-zero, process it normally.  Otherwise, record it
-    // as being zero-width.
-    if (portWidth)
-      tappedPorts.insert({key, port});
-    else
-      zeroWidthTaps.insert(key);
-  }
-  void gatherTap(Annotation anno, Operation *op) {
-    auto key = getKey(anno);
-    annos.insert({key, anno});
-    assert(!tappedOps.count(key) && "ambiguous tap annotation");
-    // If the port width is targeting a module (e.g., a blackbox) or if it has a
-    // non-zero width, process it normally.  Otherwise, record it as being
-    // zero-width.
-    if (isa<FModuleLike>(op) || op->getResult(0)
-                                    .getType()
-                                    .cast<FIRRTLBaseType>()
-                                    .getBitWidthOrSentinel())
-      tappedOps.insert({key, op});
-    else
-      zeroWidthTaps.insert(key);
-  }
-
-  /// Returns a port's `inner_sym`, adding one if necessary.
-  StringAttr getOrAddInnerSym(FModuleLike module, size_t portIdx);
-  /// Obtain an inner reference to an operation, possibly adding an `inner_sym`
-  /// to that operation.
-  InnerRefAttr getInnerRefTo(Operation *op);
-  /// Obtain an inner reference to a module port, possibly adding an `inner_sym`
-  /// to that port.
-  InnerRefAttr getInnerRefTo(FModuleLike module, size_t portIdx);
-
-  /// Get the cached namespace for a module.
-  ModuleNamespace &getModuleNamespace(FModuleLike module) {
-    auto it = moduleNamespaces.find(module);
-    if (it != moduleNamespaces.end())
-      return it->second;
-    return moduleNamespaces.insert({module, ModuleNamespace(module)})
-        .first->second;
-  }
-
-  DenseMap<Key, Annotation> annos;
-  DenseMap<Key, Operation *> tappedOps;
-  DenseSet<Key> zeroWidthTaps;
-  DenseMap<Key, Port> tappedPorts;
-  SmallVector<PortWiring, 8> portWiring;
-
-  /// The name of the directory where data and mem tap modules should be
-  /// output.
-  StringAttr maybeExtractDirectory = {};
-
-  /// Cached module namespaces.
-  DenseMap<Operation *, ModuleNamespace> moduleNamespaces;
-
-  /// The circuit symbol table, used to look up NLAs.
-  SymbolTable *circuitSymbols;
-};
-
-void GrandCentralTapsPass::runOnOperation() {
-  auto circuitOp = getOperation();
-  LLVM_DEBUG(llvm::dbgs() << "Running the GCT Data Taps pass\n");
-  SymbolTable symtbl(circuitOp);
-  circuitSymbols = &symtbl;
-  hw::InnerSymbolTableCollection innerSymTblCol(circuitOp);
-  hw::InnerRefNamespace innerRefNS{symtbl, innerSymTblCol};
-
-  // Here's a rough idea of what the Scala code is doing:
-  // - Gather the `source` of all `keys` of all `DataTapsAnnotation`s throughout
-  //   the design.
-  // - Convert the sources, which are specified on modules, to the absolute
-  //   paths in all instances. E.g. module M tap x will produce a.x and b.x if
-  //   there are two instances a and b of module M in the design.
-  // - All data tap keys are specified on black box ports.
-  // - The code then processes every DataTapsAnnotation separately as follows
-  //   (with the targeted blackbox and keys):
-  // - Check for collisions between SV keywords and key port names (skip this).
-  // - Find all instances of the blackbox, but then just pick the first one (we
-  //   should probably do this for each?)
-  // - Process each key independently as follows:
-  // - Look up the absolute path of the source in the map. Ensure it exists and
-  //   is unambiguous. Make it relative to the blackbox instance path.
-  // - Look up the port on the black box.
-  // - Create a hierarchical SV name and store this as an assignment to the
-  //   blackbox port.
-  //   - DeletedDataTapKey: skip and don't create a wiring
-  //   - LiteralDataTapKey: just the literal
-  //   - ReferenceDataTapKey: relative path with "." + source name
-  //   - DataTapModuleSignalKey: relative path with "." + internal path
-  // - Generate a body for the blackbox module with the signal mapping
-
-  AnnotationSet circuitAnnotations(circuitOp);
-  if (auto extractAnno =
-          circuitAnnotations.getAnnotation(extractGrandCentralClass)) {
-    auto directory = extractAnno.getMember<StringAttr>("directory");
-    if (!directory) {
-      circuitOp->emitError()
-          << "contained an invalid 'ExtractGrandCentralAnnotation' that does "
-             "not contain a 'directory' field: "
-          << extractAnno.getDict();
-      return signalPassFailure();
-    }
-    maybeExtractDirectory = directory;
-  }
-
-  // Build a generator for absolute module and instance paths in the design.
-  InstancePathCache instancePaths(getAnalysis<InstanceGraph>());
-
-  // Gather a list of extmodules that have data or mem tap annotations to be
-  // expanded.
-  SmallVector<AnnotatedExtModule, 4> modules;
-  for (auto extModule : llvm::make_early_inc_range(
-           circuitOp.getBodyBlock()->getOps<FExtModuleOp>())) {
-
-    // If the external module indicates that it is a data or mem tap, but does
-    // not actually contain any taps (it has no ports), then delete the module
-    // and all instantiations of it.
-    AnnotationSet annotations(extModule);
-    if (annotations.hasAnnotation(dataTapsBlackboxClass) &&
-        !extModule.getNumPorts()) {
-      LLVM_DEBUG(llvm::dbgs() << "Extmodule " << extModule.getName()
-                              << " is a data/memtap that has no ports and "
-                                 "will be deleted\n";);
-      for (auto *use : instancePaths.instanceGraph[extModule]->uses())
-        use->getInstance().erase();
-      extModule.erase();
-      continue;
-    }
-
-    // Go through the module ports and collect the annotated ones.
-    AnnotatedExtModule result{extModule, {}, {}, {}};
-    result.filteredPortAnnos.reserve(extModule.getNumPorts());
-    for (unsigned argNum = 0, e = extModule.getNumPorts(); argNum < e;
-         ++argNum) {
-      // Go through all annotations on this port and add the data tap key and
-      // mem tap ones to the list.
-      auto annos = AnnotationSet::forPort(extModule, argNum);
-      annos.removeAnnotations([&](Annotation anno) {
-        if (anno.isClass(memTapPortClass, deletedKeyClass, literalKeyClass,
-                         internalKeyPortClass, referenceKeyPortClass)) {
-          result.portAnnos.push_back({argNum, anno});
-          return true;
-        }
-        return false;
-      });
-      result.filteredPortAnnos.push_back(annos);
-    }
-
-    // If there are data tap annotations on the module, which is likely the
-    // case, create a filtered array of annotations with them removed.
-    AnnotationSet annos(extModule.getOperation());
-    annos.removeAnnotations(
-        [&](Annotation anno) { return anno.isClass(dataTapsBlackboxClass); });
-    result.filteredModuleAnnos = annos.getArrayAttr();
-
-    if (!result.portAnnos.empty())
-      modules.push_back(std::move(result));
-  }
-
-  LLVM_DEBUG({
-    for (auto m : modules) {
-      llvm::dbgs() << "Extmodule " << m.extModule.getName() << " has "
-                   << m.portAnnos.size() << " port annotations\n";
-    }
-  });
-
-  // Fast path if there's nothing to do.
-  if (modules.empty()) {
-    markAllAnalysesPreserved();
-    return;
-  }
-
-  // Gather the annotated ports and operations throughout the design that we are
-  // supposed to tap in one way or another.
-  tappedPorts.clear();
-  tappedOps.clear();
-  circuitOp.walk([&](Operation *op) { gatherAnnotations(op); });
-
-  LLVM_DEBUG({
-    llvm::dbgs() << "Tapped ports:\n";
-    for (auto it : tappedPorts)
-      llvm::dbgs() << "- " << it.first << ": "
-                   << it.second.first->getAttr(SymbolTable::getSymbolAttrName())
-                   << " port #" << it.second.second << "\n";
-    llvm::dbgs() << "Tapped ops:\n";
-    for (auto it : tappedOps)
-      llvm::dbgs() << "- " << it.first << ": " << *it.second << "\n";
-  });
-
-  // Process each black box independently.
-  for (auto blackBox : modules) {
-    LLVM_DEBUG(llvm::dbgs() << "Generating impls for "
-                            << blackBox.extModule.getName() << "\n");
-
-    // As a first step, gather a list of all absolute paths to instances of
-    // this black box.
-    auto paths = instancePaths.getAbsolutePaths(blackBox.extModule);
-    LLVM_DEBUG({
-      for (auto path : paths)
-        llvm::dbgs() << "- " << path << "\n";
-    });
-
-    // Go through the port annotations of the tap module and generate a
-    // hierarchical path for each.
-    portWiring.clear();
-    portWiring.reserve(blackBox.portAnnos.size());
-    for (auto portAnno : blackBox.portAnnos) {
-      processAnnotation(portAnno, blackBox, instancePaths);
-    }
-
-    LLVM_DEBUG({
-      llvm::dbgs() << "- Wire up as follows:\n";
-      for (auto wiring : portWiring) {
-        llvm::dbgs() << "- Port " << wiring.portNum << ":\n";
-        for (auto path : wiring.prefices) {
-          llvm::dbgs() << "  - " << path;
-          if (wiring.nla)
-            llvm::dbgs() << "." << wiring.nla.getNamepathAttr();
-          if (!wiring.suffix.empty())
-            llvm::dbgs() << " $ " << wiring.suffix;
-          llvm::dbgs() << "\n";
-        }
-      }
-    });
-
-    // Now we have an awkward mapping problem. We have multiple data tap
-    // module instances, which reference things in modules that in turn have
-    // multiple instances. This is a side-effect of how Grand Central
-    // annotates things on modules rather than instances. (However in practice
-    // these will have a one-to-one correspondence due to CHIRRTL having fully
-    // uniquified instances.) To solve this issue, create a dedicated
-    // implementation for every data tap instance, and among the possible
-    // targets for the data taps choose the one with the shortest relative
-    // path to the data tap instance.
-    ImplicitLocOpBuilder builder(blackBox.extModule->getLoc(),
-                                 blackBox.extModule);
-    unsigned implIdx = 0;
-    for (auto path : paths) {
-      builder.setInsertionPointAfter(blackBox.extModule);
-
-      // Get the list of ports from the original extmodule, and update the
-      // annotations such that they no longer contain any data/mem taps.
-      auto ports = blackBox.extModule.getPorts();
-      for (auto port : llvm::zip(ports, blackBox.filteredPortAnnos)) {
-        std::get<0>(port).annotations = std::get<1>(port);
-      }
-
-      // Create a new firrtl.module that implements the data tap.
-      auto name =
-          StringAttr::get(&getContext(), Twine(blackBox.extModule.getName()) +
-                                             "_impl_" + Twine(implIdx++));
-      LLVM_DEBUG(llvm::dbgs()
-                 << "Implementing " << name << " ("
-                 << blackBox.extModule.getName() << " for " << path << ")\n");
-      auto impl =
-          builder.create<FModuleOp>(name, ports, blackBox.filteredModuleAnnos);
-      SymbolTable::setSymbolVisibility(
-          impl, SymbolTable::getSymbolVisibility(blackBox.extModule));
-
-      // If extraction information was provided via an
-      // `ExtractGrandCentralAnnotation`, put the created data or memory taps
-      // inside this directory.
-      if (maybeExtractDirectory)
-        impl->setAttr("output_file",
-                      hw::OutputFileAttr::getFromDirectoryAndFilename(
-                          &getContext(), maybeExtractDirectory.getValue(),
-                          impl.getName() + ".sv"));
-      impl->setAttr("comment",
-                    builder.getStringAttr("VCS coverage exclude_file"));
-      builder.setInsertionPointToEnd(impl.getBodyBlock());
-
-      // Connect the output ports to the appropriate tapped object.
-      for (auto port : portWiring) {
-        LLVM_DEBUG(llvm::dbgs() << "- Wiring up port " << port.portNum << "\n");
-
-        // Ignore the port if it is marked for deletion.
-        if (port.zeroWidth)
-          continue;
-
-        // Handle literals. We send the literal string off to the FIRParser to
-        // translate into whatever ops are necessary. This yields a handle on
-        // value we're supposed to drive.
-        if (port.literal) {
-          LLVM_DEBUG(llvm::dbgs() << "  - Connecting literal "
-                                  << port.literal.value << "\n");
-          auto literal =
-              builder.create<ConstantOp>(port.literal.type, port.literal.value);
-          auto arg = impl.getArgument(port.portNum);
-          builder.create<ConnectOp>(arg, literal);
-          continue;
-        }
-        // The code tries to come up with a relative path from the data tap
-        // instance (path being the absolute path to that instance) to the
-        // tapped thing (prefix being the path to the tapped port, wire, or
-        // memory) by calling stripCommonPrefix(prefix, path).  If the tapped
-        // thing includes an NLA, then the NLA path is appended to the rest of
-        // the path before the common prefix stripping is done.
-
-        // Determine the shortest hierarchical prefix from this black box
-        // instance to the tapped object.
-        Optional<SmallVector<HWInstanceLike>> shortestPrefix;
-        for (auto prefix : port.prefices) {
-
-          // Append the NLA path to the instance graph-determined path.
-          SmallVector<HWInstanceLike> prefixWithNLA(prefix.begin(),
-                                                    prefix.end());
-          if (port.nla) {
-            for (auto segment : port.nla.getNamepath().getValue().drop_back())
-              if (auto ref = segment.dyn_cast<InnerRefAttr>()) {
-                prefixWithNLA.push_back(
-                    cast<HWInstanceLike>(innerRefNS.lookupOp(ref)));
-              }
-          }
-
-          auto relative = stripCommonPrefix(prefixWithNLA, path);
-          if (!shortestPrefix || relative.size() < shortestPrefix->size())
-            shortestPrefix.emplace(relative.begin(), relative.end());
-        }
-        if (!shortestPrefix) {
-          LLVM_DEBUG(llvm::dbgs() << "  - Has no prefix, skipping\n");
-          continue;
-        }
-        LLVM_DEBUG(llvm::dbgs()
-                   << "  - Shortest prefix " << *shortestPrefix << "\n");
-
-        // Determine the module at which the hierarchical name should start.
-        FModuleLike rootModule;
-        if (shortestPrefix->empty()) {
-          if (port.target.hasPort())
-            rootModule = cast<FModuleLike>(port.target.getOp());
-          else
-            rootModule = port.target.getOp()->getParentOfType<FModuleLike>();
-        } else
-          rootModule = shortestPrefix->front()->getParentOfType<FModuleLike>();
-
-        SmallVector<Attribute> symbols;
-        SmallString<128> hname;
-        auto addSymbol = [&](Attribute symbol) {
-          auto id = symbols.size();
-          symbols.push_back(symbol);
-          if (!hname.empty())
-            hname += '.';
-          ("{{" + Twine(id) + "}}").toVector(hname);
-        };
-
-        // Concatenate the prefix into a proper full hierarchical name.
-        addSymbol(
-            FlatSymbolRefAttr::get(SymbolTable::getSymbolName(rootModule)));
-        for (auto inst : *shortestPrefix)
-          addSymbol(getInnerRefTo(inst));
-        FIRRTLBaseType tpe;
-        if (port.target.getOp()) {
-          Attribute leaf;
-          if (port.target.hasPort()) {
-            leaf = getInnerRefTo(port.target.getOp(), port.target.getPort());
-            tpe = cast<FModuleLike>(port.target.getOp())
-                      .getPortType(port.target.getPort())
-                      .cast<FIRRTLBaseType>();
-          } else {
-            leaf = getInnerRefTo(port.target.getOp());
-            tpe = port.target.getOp()
-                      ->getResult(0)
-                      .getType()
-                      .cast<FIRRTLBaseType>();
-          }
-          addSymbol(leaf);
-        }
-        auto fieldID = port.targetFieldID;
-        while (fieldID) {
-          TypeSwitch<FIRRTLType>(tpe)
-              .template Case<FVectorType>([&](FVectorType vector) {
-                unsigned index = vector.getIndexForFieldID(fieldID);
-                tpe = vector.getElementType();
-                fieldID -= vector.getFieldID(index);
-                hname += ("[" + Twine(index) + "]").str();
-              })
-              .template Case<BundleType>([&](BundleType bundle) {
-                unsigned index = bundle.getIndexForFieldID(fieldID);
-                tpe = bundle.getElementType(index);
-                fieldID -= bundle.getFieldID(index);
-                // FIXME: Invalid verilog names (e.g. "begin", "reg", .. ) will
-                // be renamed at ExportVerilog so the path constructed here
-                // might become invalid. We can use an inner name ref to encode
-                // a reference to a subfield.
-
-                hname += "." + bundle.getElement(index).name.getValue().str();
-              })
-              .Default([&](auto) {
-                blackBox.extModule.emitError()
-                    << "ReferenceDataTapKey on port has invalid field ID";
-                signalPassFailure();
-                fieldID = 0;
-              });
-        }
-
-        if (!port.suffix.empty()) {
-          hname += '.';
-          hname += port.suffix;
-        }
-        LLVM_DEBUG({
-          llvm::dbgs() << "  - Connecting as " << hname;
-          if (!symbols.empty()) {
-            llvm::dbgs() << " (";
-            llvm::interleave(
-                symbols, llvm::dbgs(),
-                [&](Attribute sym) { llvm::dbgs() << sym; }, ".");
-            llvm::dbgs() << ")";
-          }
-          llvm::dbgs() << "\n";
-        });
-
-        // Add a verbatim op that assigns this module port.
-        auto arg = impl.getArgument(port.portNum);
-        auto hnameExpr = builder.create<VerbatimExprOp>(
-            arg.getType().cast<FIRRTLType>(), hname, ValueRange{}, symbols);
-        builder.create<ConnectOp>(arg, hnameExpr);
-      }
-
-      // Switch the instance from the original extmodule to this
-      // implementation. CAVEAT: If the same black box data tap module is
-      // instantiated in a parent module that itself is instantiated in
-      // different locations, this will pretty arbitrarily pick one of those
-      // locations.
-      path.back()->setAttr("moduleName", SymbolRefAttr::get(name));
-    }
-
-    // Drop the original black box module.
-    blackBox.extModule.erase();
-  }
-}
-
-/// Gather the annotations on ports and operations into the `tappedPorts` and
-/// `tappedOps` maps.
-void GrandCentralTapsPass::gatherAnnotations(Operation *op) {
-  if (isa<FModuleOp, FExtModuleOp>(op)) {
-    // Handle port annotations on module/extmodule ops.
-    auto gather = [&](unsigned argNum, Annotation anno) {
-      if (anno.isClass(referenceKeySourceClass)) {
-        gatherTap(anno, Port{op, argNum});
-        return true;
-      }
-      return false;
-    };
-    AnnotationSet::removePortAnnotations(op, gather);
-
-    // Handle internal data taps.
-    // Note that these work for both extmodules AND regular modules.
-    // Note also that we do NOT currently check that the String target of an
-    // internalKeySourceClass actually corresponds to anything in regular
-    // modules.
-    if (isa<FModuleOp, FExtModuleOp>(op)) {
-      auto gather = [&](Annotation anno) {
-        if (anno.isClass(internalKeySourceClass)) {
-          gatherTap(anno, op);
-          return true;
-        }
-        return false;
-      };
-      AnnotationSet::removeAnnotations(op, gather);
-    }
-
-    return;
-  }
-
-  // Go through all annotations on this op and extract the interesting
-  // ones. Note that the way tap annotations are scattered to their
-  // targets, we should never see multiple values or memories annotated
-  // with the exact same annotation (hence the asserts).
-  AnnotationSet::removeAnnotations(op, [&](Annotation anno) {
-    if (anno.isClass(memTapSourceClass, referenceKeySourceClass)) {
-      gatherTap(anno, op);
-      return true;
-    }
-    return false;
-  });
-}
-
-void GrandCentralTapsPass::processAnnotation(AnnotatedPort &portAnno,
-                                             AnnotatedExtModule &blackBox,
-                                             InstancePathCache &instancePaths) {
-  LLVM_DEBUG(llvm::dbgs() << "- Processing port " << portAnno.portNum
-                          << " anno " << portAnno.anno.getDict() << "\n");
-  auto key = getKey(portAnno.anno);
-  auto portName = blackBox.extModule.getPortNameAttr(portAnno.portNum);
-  PortWiring wiring;
-  wiring.portNum = portAnno.portNum;
-
-  // Lookup the sibling annotation no the target. This may not exist, e.g. in
-  // the case of a `LiteralDataTapKey`, in which use the annotation on the
-  // data tap module port again.
-  auto targetAnnoIt = annos.find(key);
-  if (portAnno.anno.isClass(memTapPortClass) && targetAnnoIt == annos.end())
-    targetAnnoIt = annos.find({key.first, {}});
-  auto targetAnno =
-      targetAnnoIt != annos.end() ? targetAnnoIt->second : portAnno.anno;
-  LLVM_DEBUG(llvm::dbgs() << "  Target anno " << targetAnno.getDict() << "\n");
-
-  // NOTE:
-  // - portAnno holds the "*.port" flavor of the annotation
-  // - targetAnno holds the "*.source" flavor of the annotation
-
-  // If the annotation is non-local, look up the corresponding NLA operation to
-  // find the exact instance path. We basically make the `wiring.prefices` array
-  // of instance paths list all the possible paths to the beginning of the NLA
-  // path. During wiring of the ports, we generate hierarchical names of the
-  // form `<prefix>.<nla-path>.<suffix>`. If we don't have an NLA, we leave it
-  // to the key-class-specific code below to come up with the possible prefices.
-  hw::HierPathOp nla;
-  if (auto nlaSym = targetAnno.getMember<FlatSymbolRefAttr>("circt.nonlocal")) {
-    nla = dyn_cast<hw::HierPathOp>(circuitSymbols->lookup(nlaSym.getAttr()));
-    assert(nla);
-    // Find all paths to the root of the NLA.
-    Operation *root = circuitSymbols->lookup(nla.root());
-    wiring.nla = nla;
-    wiring.prefices = instancePaths.getAbsolutePaths(root);
-  }
-
-  wiring.targetFieldID = targetAnno.getFieldID();
-  if (portAnno.anno.getFieldID()) {
-    blackBox.extModule.emitError(
-        "external module ports must have ground types");
-    signalPassFailure();
-  }
-
-  // Handle data taps on signals and ports.
-  if (targetAnno.isClass(referenceKeySourceClass)) {
-    // Handle ports.
-    if (auto port = tappedPorts.lookup(key)) {
-      if (!nla)
-        wiring.prefices = instancePaths.getAbsolutePaths(port.first);
-      wiring.target = PortWiring::Target(port.first, port.second);
-      portWiring.push_back(std::move(wiring));
-      return;
-    }
-
-    // Handle operations.
-    if (auto op = tappedOps.lookup(key)) {
-      // We require the target to be a wire or node, such that it gets a name
-      // during Verilog emission.
-      if (!isa<WireOp, NodeOp, RegOp, RegResetOp>(op)) {
-        auto diag = blackBox.extModule.emitError("ReferenceDataTapKey on port ")
-                    << portName << " must be a wire, node, or reg";
-        diag.attachNote(op->getLoc()) << "referenced operation is here:";
-        signalPassFailure();
-        return;
-      }
-
-      if (!nla)
-        wiring.prefices =
-            instancePaths.getAbsolutePaths(op->getParentOfType<FModuleOp>());
-      wiring.target = PortWiring::Target(op);
-
-      // If the tapped operation is trivially driven by a constant, set
-      // information about the literal so that this can later be used instead of
-      // an XMR.
-      if (auto driver = getDriverFromConnect(op->getResult(0)))
-        if (auto constant =
-                dyn_cast_or_null<ConstantOp>(driver.getDefiningOp()))
-          wiring.literal = {constant.getValueAttr(), constant.getType()};
-
-      portWiring.push_back(std::move(wiring));
-      return;
-    }
-
-    // If the port is zero-width, then mark it as
-    if (zeroWidthTaps.contains(key)) {
-      wiring.zeroWidth = true;
-      portWiring.push_back(std::move(wiring));
-      return;
-    }
-
-    // The annotation scattering must have placed this annotation on some
-    // target operation or block argument, which we should have picked up in
-    // the tapped args or ops maps.
-    blackBox.extModule.emitOpError(
-        "ReferenceDataTapKey annotation was not scattered to "
-        "an operation: ")
-        << targetAnno.getDict();
-    signalPassFailure();
-    return;
-  }
-
-  // Handle data taps on black boxes.
-  if (targetAnno.isClass(internalKeySourceClass)) {
-    auto op = tappedOps.lookup(key);
-    if (!op) {
-      blackBox.extModule.emitOpError(
-          "DataTapModuleSignalKey annotation was not scattered to "
-          "an operation: ")
-          << targetAnno.getDict();
-      signalPassFailure();
-      return;
-    }
-
-    // Extract the internal path we're supposed to append.
-    auto internalPath = targetAnno.getMember<StringAttr>("internalPath");
-    if (!internalPath) {
-      blackBox.extModule.emitError("DataTapModuleSignalKey annotation on port ")
-          << portName << " missing \"internalPath\" attribute";
-      signalPassFailure();
-      return;
-    }
-
-    if (!nla)
-      wiring.prefices = instancePaths.getAbsolutePaths(op);
-    wiring.suffix = internalPath.getValue();
-    portWiring.push_back(std::move(wiring));
-    return;
-  }
-
-  // Handle data taps with literals.
-  if (targetAnno.isClass(literalKeyClass)) {
-    auto literal = portAnno.anno.getMember<StringAttr>("literal");
-    if (!literal) {
-      blackBox.extModule.emitError("LiteralDataTapKey annotation on port ")
-          << portName << " missing \"literal\" attribute";
-      signalPassFailure();
-      return;
-    }
-
-    // Parse the literal.
-    auto parsed =
-        parseIntegerLiteral(blackBox.extModule.getContext(), literal.getValue(),
-                            blackBox.extModule.getLoc());
-    if (failed(parsed)) {
-      blackBox.extModule.emitError("LiteralDataTapKey annotation on port ")
-          << portName << " has invalid literal \"" << literal.getValue()
-          << "\"";
-      signalPassFailure();
-      return;
-    }
-
-    wiring.literal = *parsed;
-    portWiring.push_back(std::move(wiring));
-    return;
-  }
-
-  // Handle memory taps.
-  if (targetAnno.isClass(memTapSourceClass)) {
-
-    // Handle operations.
-    if (auto *op = tappedOps.lookup(key)) {
-      // We require the target to be a wire or node, such that it gets a name
-      // during Verilog emission.
-      if (!isa<WireOp, NodeOp, RegOp, RegResetOp>(op)) {
-        auto diag = blackBox.extModule.emitError("MemTapAnnotation on port ")
-                    << portName << " must be a wire, node, or reg";
-        diag.attachNote(op->getLoc()) << "referenced operation is here:";
-        signalPassFailure();
-        return;
-      }
-
-      if (!nla)
-        wiring.prefices =
-            instancePaths.getAbsolutePaths(op->getParentOfType<FModuleOp>());
-      wiring.target = PortWiring::Target(op);
-      portWiring.push_back(std::move(wiring));
-      return;
-    }
-    // This handles the case when the memtap is on a MemOp, which shouldn't have
-    // the PortID attribute. Lookup the op without the portID key.
-    if (auto *op = tappedOps.lookup({key.first, {}})) {
-
-      // Extract the memory location we're supposed to access.
-      auto word = portAnno.anno.getMember<IntegerAttr>("portID");
-      if (!word) {
-        blackBox.extModule.emitError("MemTapAnnotation annotation on port ")
-            << portName << " missing \"word\" attribute";
-        signalPassFailure();
-        return;
-      }
-      // Formulate a hierarchical reference into the memory.
-      // CAVEAT: This just assumes that the memory will map to something that
-      // can be indexed in the final Verilog. If the memory gets turned into
-      // an instance of some sort, we lack the information necessary to go in
-      // and access individual elements of it. This will break horribly since
-      // we generate memory impls out-of-line already, and memories coming
-      // from an external generator are even worse. This needs a special node
-      // in the IR that can properly inject the memory array on emission.
-      if (!nla)
-        wiring.prefices =
-            instancePaths.getAbsolutePaths(op->getParentOfType<FModuleOp>());
-      wiring.target = PortWiring::Target(op);
-      ("Memory[" + Twine(word.getValue().getLimitedValue()) + "]")
-          .toVector(wiring.suffix);
-      portWiring.push_back(std::move(wiring));
-      return;
-    }
-    blackBox.extModule.emitOpError(
-        "MemTapAnnotation annotation was not scattered to "
-        "an operation: ")
-        << targetAnno.getDict();
-    signalPassFailure();
-    return;
-  }
-
-  // We never arrive here since the above code that populates the portAnnos
-  // list only adds annotations that we handle in one of the if statements
-  // above.
-  llvm_unreachable("portAnnos is never populated with unsupported annos");
-}
-
-InnerRefAttr GrandCentralTapsPass::getInnerRefTo(Operation *op) {
-  return ::getInnerRefTo(op, "gct_sym",
-                         [&](FModuleOp mod) -> ModuleNamespace & {
-                           return getModuleNamespace(mod);
-                         });
-}
-
-InnerRefAttr GrandCentralTapsPass::getInnerRefTo(FModuleLike module,
-                                                 size_t portIdx) {
-  return ::getInnerRefTo(module, portIdx, "gct_sym",
-                         [&](FModuleLike mod) -> ModuleNamespace & {
-                           return getModuleNamespace(mod);
-                         });
-}
-
-std::unique_ptr<mlir::Pass> circt::firrtl::createGrandCentralTapsPass() {
-  return std::make_unique<GrandCentralTapsPass>();
-}
diff --git a/lib/Dialect/FIRRTL/Transforms/InferResets.cpp b/lib/Dialect/FIRRTL/Transforms/InferResets.cpp
index b445ff6a3..16be4b5fa 100644
--- a/lib/Dialect/FIRRTL/Transforms/InferResets.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/InferResets.cpp
@@ -1687,7 +1687,7 @@ void InferResetsPass::implementAsyncReset(Operation *op, FModuleOp module,
       instOp->erase();
       instOp = newInstOp;
     } else if (domain.existingPort.has_value()) {
-      auto idx = domain.existingPort.value();
+      auto idx = *domain.existingPort;
       instReset = instOp.getResult(idx);
       LLVM_DEBUG(llvm::dbgs() << "  - Using result #" << idx << " as reset\n");
     }
diff --git a/lib/Dialect/FIRRTL/Transforms/InferWidths.cpp b/lib/Dialect/FIRRTL/Transforms/InferWidths.cpp
index 708e2dc31..e86871394 100644
--- a/lib/Dialect/FIRRTL/Transforms/InferWidths.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/InferWidths.cpp
@@ -179,12 +179,12 @@ struct IdExpr : public ExprBase<IdExpr, Expr::Kind::Id> {
 /// A known constant value.
 struct KnownExpr : public ExprBase<KnownExpr, Expr::Kind::Known> {
   KnownExpr(int32_t value) : ExprBase() { solution = value; }
-  void print(llvm::raw_ostream &os) const { os << solution.value(); }
+  void print(llvm::raw_ostream &os) const { os << *solution; }
   bool operator==(const KnownExpr &other) const {
-    return solution.value() == other.solution.value();
+    return *solution == *other.solution;
   }
   llvm::hash_code hash_value() const {
-    return llvm::hash_combine(Expr::hash_value(), solution.value());
+    return llvm::hash_combine(Expr::hash_value(), *solution);
   }
 };
 
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp b/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
index b905c346a..aea58a9f5 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
@@ -526,7 +526,7 @@ ArrayAttr TypeLoweringVisitor::filterAnnotations(MLIRContext *ctxt,
           updateAnnotationFieldID(ctxt, opAttr, field.fieldID, cache.i64ty));
       continue;
     }
-    auto fieldID = maybeFieldID.value();
+    auto fieldID = *maybeFieldID;
     // Check whether the annotation falls into the range of the current field.
     if (fieldID != 0 &&
         !(fieldID >= field.fieldID &&
@@ -1134,7 +1134,7 @@ bool TypeLoweringVisitor::visitExpr(BitCastOp op) {
     // Loop over the leaf aggregates and concat each of them to get a UInt.
     // Bitcast the fields to handle nested aggregate types.
     for (const auto &field : llvm::enumerate(fields)) {
-      auto fieldBitwidth = getBitWidth(field.value().type).value();
+      auto fieldBitwidth = *getBitWidth(field.value().type);
       // Ignore zero width fields, like empty bundles.
       if (fieldBitwidth == 0)
         continue;
@@ -1161,7 +1161,7 @@ bool TypeLoweringVisitor::visitExpr(BitCastOp op) {
     auto clone = [&](const FlatBundleFieldEntry &field,
                      ArrayAttr attrs) -> Value {
       // All the fields must have valid bitwidth, a requirement for BitCastOp.
-      auto fieldBits = getBitWidth(field.type).value();
+      auto fieldBits = *getBitWidth(field.type);
       // If empty field, then it doesnot have any use, so replace it with an
       // invalid op, which should be trivially removed.
       if (fieldBits == 0)
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp b/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
index ee59d4da3..1dee01501 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
@@ -226,7 +226,7 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
         auto iter = dataflowAt.find(I->getData());
         if (iter != dataflowAt.end()) {
           for (auto init = refSendPathList[iter->getSecond()]; init.second;
-               init = refSendPathList[init.second.value()])
+               init = refSendPathList[*init.second])
             llvm::dbgs() << "\n path ::" << init.first << "::" << init.second;
         }
         llvm::dbgs() << "\n Done\n"; // Finish set.
@@ -241,7 +241,7 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
   // Replace the RefResolveOp with verbatim op representing the XMR.
   LogicalResult handleRefResolve(RefResolveOp resolve) {
     auto resWidth = getBitWidth(resolve.getType());
-    if (resWidth.has_value() && resWidth.value() == 0) {
+    if (resWidth.has_value() && *resWidth == 0) {
       // Donot emit 0 width XMRs, replace it with constant 0.
       ImplicitLocOpBuilder builder(resolve.getLoc(), resolve);
       auto zeroUintType = UIntType::get(builder.getContext(), 0);
@@ -258,8 +258,8 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
     SmallString<128> xmrString;
     size_t lastIndex;
     while (remoteOpPath) {
-      lastIndex = remoteOpPath.value();
-      auto entr = refSendPathList[remoteOpPath.value()];
+      lastIndex = *remoteOpPath;
+      auto entr = refSendPathList[*remoteOpPath];
       refSendPath.push_back(entr.first);
       remoteOpPath = entr.second;
     }
@@ -430,11 +430,11 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
     auto indx = refSendPathList.size();
     dataflowAt[leader] = indx;
     if (continueFrom.has_value()) {
-      if (!refSendPathList[continueFrom.value()].first) {
+      if (!refSendPathList[*continueFrom].first) {
         // This handles the case when the InnerRef is set to null at the
         // following path, that implies the path ends at this node, so copy the
         // xmrPathSuffix and end the path here.
-        auto xmrIter = xmrPathSuffix.find(continueFrom.value());
+        auto xmrIter = xmrPathSuffix.find(*continueFrom);
         if (xmrIter != xmrPathSuffix.end()) {
           SmallString<128> xmrSuffix = xmrIter->getSecond();
           // The following assignment to the DenseMap can potentially reallocate
@@ -574,6 +574,7 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
                      builder.create<hw::HierPathOp>(
                          circuitNamespace->newName("xmrPath"), pathArray)})
             .first->second;
+    path.setVisibility(SymbolTable::Visibility::Private);
 
     // Save the insertion point so other unique HierPathOps will be created
     // after this one.
diff --git a/lib/Dialect/FIRRTL/Transforms/RandomizeRegisterInit.cpp b/lib/Dialect/FIRRTL/Transforms/RandomizeRegisterInit.cpp
index da51f51c1..5d429baf8 100644
--- a/lib/Dialect/FIRRTL/Transforms/RandomizeRegisterInit.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/RandomizeRegisterInit.cpp
@@ -61,7 +61,7 @@ static void createRandomizationAttributes(FModuleOp mod) {
     auto start = builder.getIntegerAttr(ui64Type, currentWidth);
     op->setAttr("firrtl.random_init_start", start);
 
-    currentWidth += regWidth.value();
+    currentWidth += *regWidth;
   });
 }
 
diff --git a/lib/Dialect/FIRRTL/Transforms/ResolveTraces.cpp b/lib/Dialect/FIRRTL/Transforms/ResolveTraces.cpp
index fd92d9827..6c8fd4ede 100644
--- a/lib/Dialect/FIRRTL/Transforms/ResolveTraces.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/ResolveTraces.cpp
@@ -222,7 +222,7 @@ void ResolveTracesPass::runOnOperation() {
     auto getNamespace = [&](FModuleLike module) -> ModuleNamespace & {
       if (!moduleNamespace)
         moduleNamespace = ModuleNamespace(module);
-      return moduleNamespace.value();
+      return *moduleNamespace;
     };
 
     // Visit the module.
diff --git a/lib/Dialect/HW/HWAttributes.cpp b/lib/Dialect/HW/HWAttributes.cpp
index 529068dbe..dd32ef9e7 100644
--- a/lib/Dialect/HW/HWAttributes.cpp
+++ b/lib/Dialect/HW/HWAttributes.cpp
@@ -887,7 +887,7 @@ static Attribute parseParamExprWithOpcode(StringRef opcodeStr,
           }))
     return {};
 
-  Optional<PEO> opcode = symbolizePEO(opcodeStr);
+  std::optional<PEO> opcode = symbolizePEO(opcodeStr);
   if (!opcode.has_value()) {
     p.emitError(p.getNameLoc(), "unknown parameter expr operator name");
     return {};
diff --git a/lib/Dialect/HW/Transforms/HWSpecialize.cpp b/lib/Dialect/HW/Transforms/HWSpecialize.cpp
index a32c9db64..3b39416a0 100644
--- a/lib/Dialect/HW/Transforms/HWSpecialize.cpp
+++ b/lib/Dialect/HW/Transforms/HWSpecialize.cpp
@@ -196,10 +196,10 @@ static void populateTypeConversion(Location loc, TypeConverter &typeConverter,
                                    ArrayAttr parameters) {
   // Possibly parametric types
   typeConverter.addConversion([=](hw::IntType type) {
-    return evaluateParametricType(loc, parameters, type).value();
+    return evaluateParametricType(loc, parameters, type);
   });
   typeConverter.addConversion([=](hw::ArrayType type) {
-    return evaluateParametricType(loc, parameters, type).value();
+    return evaluateParametricType(loc, parameters, type);
   });
 
   // Valid target types.
diff --git a/lib/Dialect/HWArith/HWArithOps.cpp b/lib/Dialect/HWArith/HWArithOps.cpp
index e400876fe..f246a5f12 100644
--- a/lib/Dialect/HWArith/HWArithOps.cpp
+++ b/lib/Dialect/HWArith/HWArithOps.cpp
@@ -89,7 +89,7 @@ ParseResult ConstantOp::parse(OpAsmParser &parser, OperationState &result) {
 //===----------------------------------------------------------------------===//
 
 LogicalResult AddOp::inferReturnTypes(MLIRContext *context,
-                                      Optional<Location> loc,
+                                      std::optional<Location> loc,
                                       ValueRange operands, DictionaryAttr attrs,
                                       mlir::RegionRange regions,
                                       SmallVectorImpl<Type> &results) {
@@ -107,7 +107,7 @@ LogicalResult AddOp::inferReturnTypes(MLIRContext *context,
 //===----------------------------------------------------------------------===//
 
 LogicalResult SubOp::inferReturnTypes(MLIRContext *context,
-                                      Optional<Location> loc,
+                                      std::optional<Location> loc,
                                       ValueRange operands, DictionaryAttr attrs,
                                       mlir::RegionRange regions,
                                       SmallVectorImpl<Type> &results) {
@@ -140,7 +140,7 @@ getSignedInheritedSignedness(IntegerType lhs, IntegerType rhs) {
 }
 
 LogicalResult MulOp::inferReturnTypes(MLIRContext *context,
-                                      Optional<Location> loc,
+                                      std::optional<Location> loc,
                                       ValueRange operands, DictionaryAttr attrs,
                                       mlir::RegionRange regions,
                                       SmallVectorImpl<Type> &results) {
@@ -160,7 +160,7 @@ LogicalResult MulOp::inferReturnTypes(MLIRContext *context,
 //===----------------------------------------------------------------------===//
 
 LogicalResult DivOp::inferReturnTypes(MLIRContext *context,
-                                      Optional<Location> loc,
+                                      std::optional<Location> loc,
                                       ValueRange operands, DictionaryAttr attrs,
                                       mlir::RegionRange regions,
                                       SmallVectorImpl<Type> &results) {
diff --git a/lib/Dialect/Handshake/HandshakeOps.cpp b/lib/Dialect/Handshake/HandshakeOps.cpp
index 2f5e07913..3743a9ae6 100644
--- a/lib/Dialect/Handshake/HandshakeOps.cpp
+++ b/lib/Dialect/Handshake/HandshakeOps.cpp
@@ -359,7 +359,7 @@ void MuxOp::getCanonicalizationPatterns(RewritePatternSet &results,
 }
 
 LogicalResult
-MuxOp::inferReturnTypes(MLIRContext *context, Optional<Location> location,
+MuxOp::inferReturnTypes(MLIRContext *context, std::optional<Location> location,
                         ValueRange operands, DictionaryAttr attributes,
                         mlir::RegionRange regions,
                         SmallVectorImpl<mlir::Type> &inferredReturnTypes) {
@@ -443,7 +443,7 @@ std::string handshake::ControlMergeOp::getResultName(unsigned int idx) {
 }
 
 LogicalResult ControlMergeOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> location, ValueRange operands,
+    MLIRContext *context, std::optional<Location> location, ValueRange operands,
     DictionaryAttr attributes, mlir::RegionRange regions,
     SmallVectorImpl<mlir::Type> &inferredReturnTypes) {
   // ControlMerge must have at least one data operand
@@ -778,7 +778,7 @@ ParseResult BranchOp::parse(OpAsmParser &parser, OperationState &result) {
 void BranchOp::print(OpAsmPrinter &p) { sostPrint(p, false); }
 
 LogicalResult ConditionalBranchOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> location, ValueRange operands,
+    MLIRContext *context, std::optional<Location> location, ValueRange operands,
     DictionaryAttr attributes, mlir::RegionRange regions,
     SmallVectorImpl<mlir::Type> &inferredReturnTypes) {
   // Return type is type of data operand (second argument), twice
@@ -835,11 +835,10 @@ bool ConditionalBranchOp::isControl() {
                                       getDataOperand());
 }
 
-LogicalResult
-SelectOp::inferReturnTypes(MLIRContext *context, Optional<Location> location,
-                           ValueRange operands, DictionaryAttr attributes,
-                           mlir::RegionRange regions,
-                           SmallVectorImpl<mlir::Type> &inferredReturnTypes) {
+LogicalResult SelectOp::inferReturnTypes(
+    MLIRContext *context, std::optional<Location> location, ValueRange operands,
+    DictionaryAttr attributes, mlir::RegionRange regions,
+    SmallVectorImpl<mlir::Type> &inferredReturnTypes) {
   // Return type is type of true operand (equivalently, of false operand)
   inferredReturnTypes.push_back(operands[1].getType());
   return success();
diff --git a/lib/Dialect/LLHD/IR/LLHDOps.cpp b/lib/Dialect/LLHD/IR/LLHDOps.cpp
index 04693e93e..5a910aad0 100644
--- a/lib/Dialect/LLHD/IR/LLHDOps.cpp
+++ b/lib/Dialect/LLHD/IR/LLHDOps.cpp
@@ -263,11 +263,10 @@ LogicalResult llhd::PtrArraySliceOp::canonicalize(llhd::PtrArraySliceOp op,
 //===----------------------------------------------------------------------===//
 
 template <class SigPtrType>
-static LogicalResult
-inferReturnTypesOfStructExtractOp(MLIRContext *context, Optional<Location> loc,
-                                  ValueRange operands, DictionaryAttr attrs,
-                                  mlir::RegionRange regions,
-                                  SmallVectorImpl<Type> &results) {
+static LogicalResult inferReturnTypesOfStructExtractOp(
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
+    DictionaryAttr attrs, mlir::RegionRange regions,
+    SmallVectorImpl<Type> &results) {
   Type type = operands[0]
                   .getType()
                   .cast<SigPtrType>()
@@ -288,7 +287,7 @@ inferReturnTypesOfStructExtractOp(MLIRContext *context, Optional<Location> loc,
 }
 
 LogicalResult llhd::SigStructExtractOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   return inferReturnTypesOfStructExtractOp<llhd::SigType>(
@@ -296,7 +295,7 @@ LogicalResult llhd::SigStructExtractOp::inferReturnTypes(
 }
 
 LogicalResult llhd::PtrStructExtractOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   return inferReturnTypesOfStructExtractOp<llhd::PtrType>(
@@ -909,7 +908,7 @@ ParseResult llhd::RegOp::parse(OpAsmParser &parser, OperationState &result) {
 void llhd::RegOp::print(OpAsmPrinter &printer) {
   printer << " " << getSignal();
   for (size_t i = 0, e = getValues().size(); i < e; ++i) {
-    Optional<llhd::RegMode> mode = llhd::symbolizeRegMode(
+    std::optional<llhd::RegMode> mode = llhd::symbolizeRegMode(
         getModes().getValue()[i].cast<IntegerAttr>().getInt());
     if (!mode) {
       emitError("invalid RegMode");
diff --git a/lib/Dialect/MSFT/ExportQuartusTcl.cpp b/lib/Dialect/MSFT/ExportQuartusTcl.cpp
index 4e0e6c7e8..c57a154bc 100644
--- a/lib/Dialect/MSFT/ExportQuartusTcl.cpp
+++ b/lib/Dialect/MSFT/ExportQuartusTcl.cpp
@@ -96,14 +96,14 @@ struct TclOutputState {
   void emit(PhysLocationAttr);
   LogicalResult emitLocationAssignment(DynInstDataOpInterface refOp,
                                        PhysLocationAttr,
-                                       Optional<StringRef> subpath);
+                                       std::optional<StringRef> subpath);
 
   LogicalResult emit(PDPhysRegionOp region);
   LogicalResult emit(PDPhysLocationOp loc);
   LogicalResult emit(PDRegPhysLocationOp);
   LogicalResult emit(DynamicInstanceVerbatimAttrOp attr);
 
-  void emitPath(hw::GlobalRefOp ref, Optional<StringRef> subpath);
+  void emitPath(hw::GlobalRefOp ref, std::optional<StringRef> subpath);
   void emitInnerRefPart(hw::InnerRefAttr innerRef);
 
   /// Get the GlobalRefOp to which the given operation is pointing. Add it to
@@ -131,7 +131,7 @@ void TclOutputState::emitInnerRefPart(hw::InnerRefAttr innerRef) {
 }
 
 void TclOutputState::emitPath(hw::GlobalRefOp ref,
-                              Optional<StringRef> subpath) {
+                              std::optional<StringRef> subpath) {
   // Traverse each part of the path.
   auto parts = ref.getNamepathAttr().getAsRange<hw::InnerRefAttr>();
   auto lastPart = std::prev(parts.end());
@@ -177,7 +177,7 @@ void TclOutputState::emit(PhysLocationAttr pla) {
 LogicalResult
 TclOutputState::emitLocationAssignment(DynInstDataOpInterface refOp,
                                        PhysLocationAttr loc,
-                                       Optional<StringRef> subpath) {
+                                       std::optional<StringRef> subpath) {
   indent() << "set_location_assignment ";
   emit(loc);
 
diff --git a/lib/Dialect/MSFT/MSFTAttributes.cpp b/lib/Dialect/MSFT/MSFTAttributes.cpp
index e1feab8c3..465f2b695 100644
--- a/lib/Dialect/MSFT/MSFTAttributes.cpp
+++ b/lib/Dialect/MSFT/MSFTAttributes.cpp
@@ -34,7 +34,7 @@ Attribute PhysLocationAttr::parse(AsmParser &p, Type type) {
       p.parseComma() || p.parseInteger(num) || p.parseGreater())
     return Attribute();
 
-  Optional<PrimitiveType> devType = symbolizePrimitiveType(devTypeStr);
+  std::optional<PrimitiveType> devType = symbolizePrimitiveType(devTypeStr);
   if (!devType) {
     p.emitError(loc, "Unknown device type '" + devTypeStr + "'");
     return Attribute();
diff --git a/lib/Dialect/MSFT/MSFTOps.cpp b/lib/Dialect/MSFT/MSFTOps.cpp
index a77fcfa1f..19acc77ab 100644
--- a/lib/Dialect/MSFT/MSFTOps.cpp
+++ b/lib/Dialect/MSFT/MSFTOps.cpp
@@ -107,7 +107,7 @@ static ParseResult parsePhysLoc(OpAsmParser &p, PhysLocationAttr &attr) {
       p.parseInteger(num))
     return failure();
 
-  Optional<PrimitiveType> devType = symbolizePrimitiveType(devTypeStr);
+  std::optional<PrimitiveType> devType = symbolizePrimitiveType(devTypeStr);
   if (!devType) {
     p.emitError(loc, "Unknown device type '" + devTypeStr + "'");
     return failure();
diff --git a/lib/Dialect/Moore/MIROps.cpp b/lib/Dialect/Moore/MIROps.cpp
index ba878e185..e49557ae6 100644
--- a/lib/Dialect/Moore/MIROps.cpp
+++ b/lib/Dialect/Moore/MIROps.cpp
@@ -21,7 +21,7 @@ using namespace circt::moore;
 //===----------------------------------------------------------------------===//
 
 LogicalResult ConcatOp::inferReturnTypes(MLIRContext *context,
-                                         Optional<Location> loc,
+                                         std::optional<Location> loc,
                                          ValueRange operands,
                                          DictionaryAttr attrs,
                                          mlir::RegionRange regions,
diff --git a/lib/Dialect/SV/SVOps.cpp b/lib/Dialect/SV/SVOps.cpp
index 21e5bc34f..eacaf74a7 100644
--- a/lib/Dialect/SV/SVOps.cpp
+++ b/lib/Dialect/SV/SVOps.cpp
@@ -1550,7 +1550,7 @@ static Type getElementTypeOfWidth(Type type, int32_t width) {
 }
 
 LogicalResult IndexedPartSelectInOutOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   auto width = attrs.get("width");
@@ -1603,7 +1603,7 @@ OpFoldResult IndexedPartSelectInOutOp::fold(ArrayRef<Attribute> constants) {
 //===----------------------------------------------------------------------===//
 
 LogicalResult IndexedPartSelectOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   auto width = attrs.get("width");
@@ -1633,7 +1633,7 @@ LogicalResult IndexedPartSelectOp::verify() {
 //===----------------------------------------------------------------------===//
 
 LogicalResult StructFieldInOutOp::inferReturnTypes(
-    MLIRContext *context, Optional<Location> loc, ValueRange operands,
+    MLIRContext *context, std::optional<Location> loc, ValueRange operands,
     DictionaryAttr attrs, mlir::RegionRange regions,
     SmallVectorImpl<Type> &results) {
   auto field = attrs.get("field");
diff --git a/lib/Dialect/Seq/SeqTypes.cpp b/lib/Dialect/Seq/SeqTypes.cpp
index fd964eea7..cbd1ba28e 100644
--- a/lib/Dialect/Seq/SeqTypes.cpp
+++ b/lib/Dialect/Seq/SeqTypes.cpp
@@ -44,7 +44,7 @@ void SeqDialect::registerTypes() {
 // HLMemType
 //===----------------------------------------------------------------------===//
 
-HLMemType HLMemType::cloneWith(Optional<ArrayRef<int64_t>> shape,
+HLMemType HLMemType::cloneWith(std::optional<ArrayRef<int64_t>> shape,
                                Type elementType) const {
   return HLMemType::get(elementType.getContext(), shape.value_or(getShape()),
                         elementType);
diff --git a/lib/Dialect/SystemC/SystemCOps.cpp b/lib/Dialect/SystemC/SystemCOps.cpp
index 04ec3e642..c562fc35c 100644
--- a/lib/Dialect/SystemC/SystemCOps.cpp
+++ b/lib/Dialect/SystemC/SystemCOps.cpp
@@ -375,8 +375,7 @@ OpFoldResult ConvertOp::fold(ArrayRef<Attribute> operands) {
     auto intermediateBw = getBitWidth(intermediateType);
 
     if (!inputBw && intermediateBw) {
-      if (inputType.isa<IntBaseType, UIntBaseType>() &&
-          intermediateBw.value() >= 64)
+      if (inputType.isa<IntBaseType, UIntBaseType>() && *intermediateBw >= 64)
         return other.getInput();
       // We cannot support input types of signed, unsigned, and vector types
       // since they have no upper bound for the bit-width.
@@ -390,7 +389,7 @@ OpFoldResult ConvertOp::fold(ArrayRef<Attribute> operands) {
           intermediateType.isa<SignedType, UnsignedType>())
         return other.getInput();
 
-      if (inputBw && inputBw.value() <= 64 &&
+      if (inputBw && *inputBw <= 64 &&
           intermediateType
               .isa<IntBaseType, UIntBaseType, SignedType, UnsignedType>())
         return other.getInput();
@@ -400,7 +399,7 @@ OpFoldResult ConvertOp::fold(ArrayRef<Attribute> operands) {
       // here could change the behavior.
     }
 
-    if (inputBw && intermediateBw && inputBw.value() <= intermediateBw.value())
+    if (inputBw && intermediateBw && *inputBw <= *intermediateBw)
       return other.getInput();
   }
 
diff --git a/lib/Scheduling/SimplexSchedulers.cpp b/lib/Scheduling/SimplexSchedulers.cpp
index 1f32e8815..39e59eaa0 100644
--- a/lib/Scheduling/SimplexSchedulers.cpp
+++ b/lib/Scheduling/SimplexSchedulers.cpp
@@ -261,7 +261,6 @@ protected:
   enum { OBJ_LATENCY = 0, OBJ_AXAP /* i.e. either ASAP or ALAP */ };
   bool fillObjectiveRow(SmallVector<int> &row, unsigned obj) override;
   void updateMargins();
-  void incrementII();
   void scheduleOperation(Operation *n);
   unsigned computeResMinII();
 
@@ -564,8 +563,8 @@ LogicalResult SimplexSchedulerBase::solveTableau() {
 
     // If we did not find a pivot column, then the entire row contained only
     // positive entries, and the problem is in principle infeasible. However, if
-    // the entry in the `parameterTColumn` is positive, we can make the LP
-    // feasible again by increasing the II.
+    // the entry in the `parameterTColumn` is positive, we can try to make the
+    // LP feasible again by increasing the II.
     int entry1Col = tableau[*pivotRow][parameter1Column];
     int entryTCol = tableau[*pivotRow][parameterTColumn];
     if (entryTCol > 0) {
@@ -574,11 +573,12 @@ LogicalResult SimplexSchedulerBase::solveTableau() {
       // would not have been a valid pivot row), and without the negation, the
       // new II would be negative.
       assert(entry1Col < 0);
-      parameterT = (-entry1Col - 1) / entryTCol + 1;
-
-      LLVM_DEBUG(dbgs() << "Increased II to " << parameterT << '\n');
-
-      continue;
+      int newParameterT = (-entry1Col - 1) / entryTCol + 1;
+      if (newParameterT > parameterT) {
+        parameterT = newParameterT;
+        LLVM_DEBUG(dbgs() << "Increased II to " << parameterT << '\n');
+        continue;
+      }
     }
 
     // Otherwise, the linear program is infeasible.
@@ -685,9 +685,8 @@ LogicalResult SimplexSchedulerBase::scheduleAt(unsigned startTimeVariable,
     return failure();
   }
 
-  // Translate S by the other parameter(s). For acyclic problems, this means
-  // setting `factor1` to `timeStep`. For cyclic problems, we perform a modulo
-  // decomposition: S = `factor1` + `factorT` * T, with `factor1` < T.
+  // Translate S by the other parameter(s). This means setting `factor1` to
+  // `timeStep`.
   //
   // This translation does not change the values of the parametric constants,
   // hence we do not need to solve the tableau again.
@@ -695,13 +694,17 @@ LogicalResult SimplexSchedulerBase::scheduleAt(unsigned startTimeVariable,
   // Note: I added a negation of the factors here, which is not mentioned in the
   // paper's text, but apparently used in the example. Without it, the intended
   // effect, i.e. making the S-column all-zero again, is not achieved.
-  if (parameterT == 0)
-    translate(parameterSColumn, /* factor1= */ -timeStep, /* factorS= */ 1,
-              /* factorT= */ 0);
-  else
-    translate(parameterSColumn, /* factor1= */ -(timeStep % parameterT),
-              /* factorS= */ 1,
-              /* factorT= */ -(timeStep / parameterT));
+  //
+  // Note 2: For cyclic problems, the paper suggested to perform a modulo
+  // decomposition: S = `factor1` + `factorT` * T, with `factor1` < T.
+  // However, this makes the value baked into the tableau dependent on
+  // `parameterT`, and it is unclear to me how to update it correctly when
+  // changing the II. I found it much more robust to fix the operations to
+  // absolute time steps, and manually shift them by the appropriate amount
+  // whenever the II is incremented (cf. adding `phiJ`, `phiN` in the modulo
+  // scheduler's `scheduleOperation` method).
+  translate(parameterSColumn, /* factor1= */ -timeStep, /* factorS= */ 1,
+            /* factorT= */ 0);
 
   return success();
 }
@@ -1007,46 +1010,33 @@ void ModuloSimplexScheduler::updateMargins() {
   }
 }
 
-void ModuloSimplexScheduler::incrementII() {
-  // Account for the shift in the frozen start times that will be caused by
-  // increasing `parameterT`: Assuming decompositions of
-  //   t = phi * II + tau  and  t' = phi * (II + 1) + tau,
-  // so the required shift is
-  //   t' - t = phi = floordiv(t / II)
-  for (auto &kv : frozenVariables) {
-    unsigned &frozenTime = kv.getSecond();
-    frozenTime += frozenTime / parameterT;
-  }
-
-  // Increment the parameter.
-  ++parameterT;
-}
-
 void ModuloSimplexScheduler::scheduleOperation(Operation *n) {
+  auto oprN = *prob.getLinkedOperatorType(n);
   unsigned stvN = startTimeVariables[n];
 
-  // Get current state of the LP, and determine range of alternative times
-  // guaranteed to be feasible.
+  // Get current state of the LP. We'll try to schedule at its current time step
+  // in the partial solution, and the II-1 following time steps. Scheduling the
+  // op to a later time step may increase the overall latency, however, as long
+  // as the solution is still feasible, we prefer that over incrementing the II
+  // to resolve resource conflicts.
   unsigned stN = getStartTime(stvN);
-  unsigned lbN = (unsigned)std::max<int>(asapTimes[stvN], stN - parameterT + 1);
-  unsigned ubN = (unsigned)std::min<int>(alapTimes[stvN], lbN + parameterT - 1);
-
-  LLVM_DEBUG(dbgs() << "Attempting to schedule at t=" << stN << ", or in ["
-                    << lbN << ", " << ubN << "]: " << *n << '\n');
+  unsigned ubN = stN + parameterT - 1;
 
-  SmallVector<unsigned> candTimes;
-  candTimes.push_back(stN);
-  for (unsigned ct = lbN; ct <= ubN; ++ct)
-    if (ct != stN)
-      candTimes.push_back(ct);
+  LLVM_DEBUG(dbgs() << "Attempting to schedule in [" << stN << ", " << ubN
+                    << "]: " << *n << '\n');
 
-  for (unsigned ct : candTimes)
+  for (unsigned ct = stN; ct <= ubN; ++ct)
     if (succeeded(mrt.enter(n, ct))) {
-      auto fixedN = scheduleAt(stvN, stN);
-      assert(succeeded(fixedN));
-      (void)fixedN;
-      LLVM_DEBUG(dbgs() << "Success at t=" << stN << " " << *n << '\n');
-      return;
+      auto fixedN = scheduleAt(stvN, ct);
+      if (succeeded(fixedN)) {
+        LLVM_DEBUG(dbgs() << "Success at t=" << ct << " " << *n << '\n');
+        return;
+      }
+      // Problem became infeasible with `n` at `ct`, roll back the MRT
+      // assignment. Also, no later time can be feasible, so stop the search
+      // here.
+      mrt.release(n);
+      break;
     }
 
   // As a last resort, increase II to make room for the op. De Dinechin's
@@ -1071,30 +1061,43 @@ void ModuloSimplexScheduler::scheduleOperation(Operation *n) {
   // We're going to revisit the current partial schedule.
   SmallVector<Operation *> moved;
   for (Operation *j : scheduled) {
+    auto oprJ = *prob.getLinkedOperatorType(j);
     unsigned stvJ = startTimeVariables[j];
     unsigned stJ = getStartTime(stvJ);
     unsigned phiJ = stJ / parameterT;
     unsigned tauJ = stJ % parameterT;
     unsigned deltaJ = 0;
 
-    // To actually resolve the resource conflicts, we move operations that are
-    // "preceded" (cf. de Dinechin's  relation) one slot to the right.
-    if (tauN < tauJ || (tauN == tauJ && phiN > phiJ) ||
-        (tauN == tauJ && phiN == phiJ && stvN < stvJ)) {
-      // TODO: Replace the last condition with a proper graph analysis.
-
-      deltaJ = 1;
-      moved.push_back(j);
-      if (tauN == tauJ)
-        deltaN = 0;
+    if (oprN == oprJ) {
+      // To actually resolve the resource conflicts, we will move operations
+      // that are "preceded" (cf. de Dinechin's  relation) one slot to the
+      // right.
+      if (tauN < tauJ || (tauN == tauJ && phiN > phiJ) ||
+          (tauN == tauJ && phiN == phiJ && stvN < stvJ)) {
+        // TODO: Replace the last condition with a proper graph analysis.
+
+        deltaJ = 1;
+        moved.push_back(j);
+        if (tauN == tauJ)
+          deltaN = 0;
+      }
     }
 
-    // Apply the move to the tableau.
-    moveBy(stvJ, deltaJ);
+    // Move operation.
+    //
+    // In order to keep the op in its current MRT slot `tauJ` after incrementing
+    // the II, we add `phiJ`:
+    //   stJ + phiJ = (phiJ * parameterT + tauJ) + phiJ
+    //              = phiJ * (parameterT + 1) + tauJ
+    //
+    // Shifting an additional `deltaJ` time steps then moves the op to a
+    // different MRT slot, in order to make room for the operation that caused
+    // the resource conflict.
+    moveBy(stvJ, phiJ + deltaJ);
   }
 
-  // Finally, increment the II.
-  incrementII();
+  // Finally, increment the II and solve to apply the moves.
+  ++parameterT;
   auto solved = solveTableau();
   assert(succeeded(solved));
   (void)solved;
@@ -1108,8 +1111,8 @@ void ModuloSimplexScheduler::scheduleOperation(Operation *n) {
     (void)enteredM;
   }
 
-  // Finally, schedule the operation. Adding `phiN` accounts for the implicit
-  // shift caused by incrementing the II; cf. `incrementII()`.
+  // Finally, schedule the operation. Again, adding `phiN` accounts for the
+  // implicit shift caused by incrementing the II.
   auto fixedN = scheduleAt(stvN, stN + phiN + deltaN);
   auto enteredN = mrt.enter(n, tauN + deltaN);
   assert(succeeded(fixedN) && succeeded(enteredN));
diff --git a/test/Conversion/FIRRTLToHW/lower-to-hw.mlir b/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
index 3e6f73dc6..daa80bfe9 100644
--- a/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
+++ b/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
@@ -1787,4 +1787,47 @@ firrtl.circuit "Simple"   attributes {annotations = [{class =
     // CHECK: sv.system "value$plusargs"(%[[foo]], %[[tmp]])
     
   }
+
+  // An internal-only analog connection between two instances should be implemented with a wire
+  firrtl.extmodule @AnalogInModA(in a: !firrtl.analog<8>)
+  firrtl.extmodule @AnalogInModB(in a: !firrtl.analog<8>)
+  firrtl.extmodule @AnalogOutModA(out a: !firrtl.analog<8>)
+  firrtl.module @AnalogMergeTwo() {
+    %result_iIn = firrtl.instance iIn @AnalogInModA(in a: !firrtl.analog<8>)
+    %result_iOut = firrtl.instance iOut @AnalogOutModA(out a: !firrtl.analog<8>)
+    firrtl.attach %result_iIn, %result_iOut : !firrtl.analog<8>, !firrtl.analog<8>
+  }
+  // CHECK-LABEL: hw.module @AnalogMergeTwo() {
+  // CHECK:         %.a.wire = sv.wire : !hw.inout<i8>
+  // CHECK:         hw.instance "iIn" @AnalogInModA(a: %.a.wire: !hw.inout<i8>) -> ()
+  // CHECK:         hw.instance "iOut" @AnalogOutModA(a: %.a.wire: !hw.inout<i8>) -> ()
+  // CHECK-NEXT:    hw.output
+  // CHECK-NEXT:  }
+
+  // An internal-only analog connection between three instances should be implemented with a wire
+  firrtl.module @AnalogMergeThree() {
+    %result_iInA = firrtl.instance iInA @AnalogInModA(in a: !firrtl.analog<8>)
+    %result_iInB = firrtl.instance iInB @AnalogInModB(in a: !firrtl.analog<8>)
+    %result_iOut = firrtl.instance iOut @AnalogOutModA(out a: !firrtl.analog<8>)
+    firrtl.attach %result_iInA, %result_iInB, %result_iOut : !firrtl.analog<8>, !firrtl.analog<8>, !firrtl.analog<8>
+  }
+  // CHECK-LABEL: hw.module @AnalogMergeThree() {
+  // CHECK:         %.a.wire = sv.wire : !hw.inout<i8>
+  // CHECK:         hw.instance "iInA" @AnalogInModA(a: %.a.wire: !hw.inout<i8>) -> ()
+  // CHECK:         hw.instance "iInB" @AnalogInModB(a: %.a.wire: !hw.inout<i8>) -> ()
+  // CHECK:         hw.instance "iOut" @AnalogOutModA(a: %.a.wire: !hw.inout<i8>) -> ()
+  // CHECK-NEXT:    hw.output
+  // CHECK-NEXT:  }
+
+  // An analog connection between two instances and a module port should be implemented with a wire
+  firrtl.module @AnalogMergeTwoWithPort(out %a: !firrtl.analog<8>) {
+    %result_iIn = firrtl.instance iIn @AnalogInModA(in a: !firrtl.analog<8>)
+    %result_iOut = firrtl.instance iOut @AnalogOutModA(out a: !firrtl.analog<8>)
+    firrtl.attach %a, %result_iIn, %result_iOut : !firrtl.analog<8>, !firrtl.analog<8>, !firrtl.analog<8>
+  }
+  // CHECK-LABEL: hw.module @AnalogMergeTwoWithPort(%a: !hw.inout<i8>) {
+  // CHECK-NEXT:    hw.instance "iIn" @AnalogInModA(a: %a: !hw.inout<i8>) -> ()
+  // CHECK-NEXT:    hw.instance "iOut" @AnalogOutModA(a: %a: !hw.inout<i8>) -> ()
+  // CHECK-NEXT:    hw.output
+  // CHECK-NEXT:  }
 }
diff --git a/test/Dialect/FIRRTL/SFCTests/data-taps-more-xmrs.fir b/test/Dialect/FIRRTL/SFCTests/data-taps-more-xmrs.fir
deleted file mode 100644
index 2583cc701..000000000
--- a/test/Dialect/FIRRTL/SFCTests/data-taps-more-xmrs.fir
+++ /dev/null
@@ -1,279 +0,0 @@
-; RUN: firtool --verilog %s | FileCheck %s
-
-circuit Top : %[[
-  {
-    "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "keys":[
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "sink":"~Top|Submodule>tap_0"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>wire_DUT",
-        "sink":"~Top|Submodule>tap_1"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>wire_Top",
-        "sink":"~Top|Submodule>tap_2"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "sink":"~Top|Submodule>tap_3"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>port_DUT",
-        "sink":"~Top|Submodule>tap_4"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>port_Top",
-        "sink":"~Top|Submodule>tap_5"
-      }
-    ]
-  },
-  {
-    "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "keys":[
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "sink":"~Top|DUT>tap_6"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>wire_DUT",
-        "sink":"~Top|DUT>tap_7"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>wire_Top",
-        "sink":"~Top|DUT>tap_8"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "sink":"~Top|DUT>tap_9"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>port_DUT",
-        "sink":"~Top|DUT>tap_10"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>port_Top",
-        "sink":"~Top|DUT>tap_11"
-      }
-    ]
-  },
-  {
-    "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "keys":[
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "sink":"~Top|Top>tap_12[0]"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>wire_DUT",
-        "sink":"~Top|Top>tap_12[1]"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>wire_Top",
-        "sink":"~Top|Top>tap_12[2]"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "sink":"~Top|Top>tap_12[3]"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top/dut:DUT>port_DUT",
-        "sink":"~Top|Top>tap_12[4]"
-      },
-      {
-        "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source":"~Top|Top>port_Top",
-        "sink":"~Top|Top>tap_12[5]"
-      }
-    ]
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>inv"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>inv"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Top>inv"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_0"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_1"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_2"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_3"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_4"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Submodule>tap_5"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_6"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_7"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_8"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_9"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_10"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|DUT>tap_11"
-  },
-  {
-    "class": "firrtl.transforms.DontTouchAnnotation",
-    "target": "~Top|Top>tap_12"
-  }
-]]
-  module Submodule :
-    output port_Submodule: UInt<1>
-    port_Submodule is invalid
-
-    wire inv: UInt<1>
-    inv is invalid
-
-    wire wire_Submodule: UInt<1>
-    wire_Submodule <= inv
-
-    wire tap_0 : UInt<1>
-    wire tap_1 : UInt<1>
-    wire tap_2 : UInt<1>
-    wire tap_3 : UInt<1>
-    wire tap_4 : UInt<1>
-    wire tap_5 : UInt<1>
-    tap_0 is invalid
-    tap_1 is invalid
-    tap_2 is invalid
-    tap_3 is invalid
-    tap_4 is invalid
-    tap_5 is invalid
-
-  module DUT :
-    output port_DUT: UInt<1>
-    port_DUT is invalid
-
-    wire inv: UInt<1>
-    inv is invalid
-
-    wire wire_DUT: UInt<1>
-    wire_DUT <= inv
-
-    inst submodule of Submodule
-
-    wire tap_6 : UInt<1>
-    wire tap_7 : UInt<1>
-    wire tap_8 : UInt<1>
-    wire tap_9 : UInt<1>
-    wire tap_10 : UInt<1>
-    wire tap_11 : UInt<1>
-    tap_6 is invalid
-    tap_7 is invalid
-    tap_8 is invalid
-    tap_9 is invalid
-    tap_10 is invalid
-    tap_11 is invalid
-
-  module Top :
-    output port_Top : UInt<1>
-    port_Top is invalid
-
-    wire inv: UInt<1>
-    inv is invalid
-
-    wire wire_Top: UInt<1>
-    wire_Top <= inv
-
-    inst dut of DUT
-    wire tap_12 : UInt<1>[6]
-    tap_12 is invalid
-
-    ; CHECK-LABEL: module Submodule
-    ; CHECK-NEXT:    input [[Submodule_tap_1_port:[a-zA-Z0-9_]+]]
-    ; CHECK-NEXT:          [[Submodule_tap_2_port:[a-zA-Z0-9_]+]]
-    ; CHECK-NEXT:          [[Submodule_tap_5_port:[a-zA-Z0-9_]+]]
-    ;
-    ; CHECK-DAG:     tap_0 = wire_Submodule;
-    ; CHECK-DAG:     tap_1 = [[Submodule_tap_1_port]];
-    ; CHECK-DAG:     tap_2 = [[Submodule_tap_2_port]];
-    ; CHECK-DAG:     tap_3 = 1'h0;
-    ; CHECK-DAG:     tap_4 = 1'h0;
-    ; CHECK-DAG:     tap_5 = [[Submodule_tap_5_port]];
-
-    ; CHECK-LABEL: module DUT
-    ; CHECK-NEXT:    input [[DUT_tap_2_port:[a-zA-Z0-9_]+]]
-    ; CHECK-NEXT:          [[DUT_tap_5_port:[a-zA-Z0-9_]+]]
-    ; CHECK-NEXT:          [[DUT_tap_8_port:[a-zA-Z0-9_]+]]
-    ; CHECK-NEXT:          [[DUT_tap_11_port:[a-zA-Z0-9_]+]]
-    ;
-    ; CHECK-DAG:     tap_6 = DUT.submodule.wire_Submodule;
-    ; CHECK-DAG:     tap_7 = wire_DUT;
-    ; CHECK-DAG:     tap_8 = [[DUT_tap_8_port]];
-    ; CHECK-DAG:     tap_9 = 1'h0;
-    ; CHECK-DAG:     tap_10 = 1'h0;
-    ; CHECK-DAG:     tap_11 = [[DUT_tap_11_port]];
-    ;
-    ; CHECK:         Submodule submodule (
-    ; CHECK-DAG:       .[[Submodule_tap_1_port]] (wire_DUT)
-    ; CHECK-DAG:       .[[Submodule_tap_2_port]] ([[DUT_tap_2_port]])
-    ; CHECK-DAG:       .[[Submodule_tap_5_port]] ([[DUT_tap_5_port]])
-
-    ; CHECK-LABEL: module Top
-    ;
-    ; CHECK-DAG:     tap_12_0 = Top.dut.submodule.wire_Submodule
-    ; CHECK-DAG:     tap_12_1 = Top.dut.wire_DUT
-    ; CHECK-DAG:     tap_12_2 = inv;
-    ; CHECK-DAG:     tap_12_3 = 1'h0
-    ; CHECK-DAG:     tap_12_4 = 1'h0
-    ; CHECK-DAG:     tap_12_5 = 1'h0
-    ;
-    ; CHECK:         DUT dut (
-    ; CHECK-DAG:       .[[DUT_tap_2_port]] (inv)
-    ; CHECK-DAG:       .[[DUT_tap_5_port]] (1'h0)
-    ; CHECK-DAG:       .[[DUT_tap_8_port]] (inv)
-    ; CHECK-DAG:       .[[DUT_tap_11_port]] (1'h0)
diff --git a/test/Dialect/FIRRTL/SFCTests/data-taps.fir b/test/Dialect/FIRRTL/SFCTests/data-taps.fir
index adc55b2ca..17250665f 100644
--- a/test/Dialect/FIRRTL/SFCTests/data-taps.fir
+++ b/test/Dialect/FIRRTL/SFCTests/data-taps.fir
@@ -8,28 +8,43 @@
 ; - github.com/sifive/$internal:
 ;   - src/test/scala/grandcentral/DataTapsTest.scala
 circuit Top : %[[
-  {
-    "class":"firrtl.transforms.NoDedupAnnotation",
-    "target":"~Top|DataTap_2"
-  },
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~Top|DataTap_2",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
         "module":"~Top|BlackBox",
         "internalPath":"foo.bar.in",
-        "portName":"~Top|DataTap_2>_0"
+        "sink":"~Top|Top>tap_0"
       },
       {
         "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
         "module":"~Top|BlackBox",
         "internalPath":"foo.bar.out",
-        "portName":"~Top|DataTap_2>_1"
+        "sink":"~Top|Top>tap_1"
       }
     ]
   },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>in"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>out"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap_0"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap_1"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap_2"
+  },
   {
     "class": "firrtl.transforms.DontTouchAnnotation",
     "target": "~Top|Child>always"
@@ -37,7 +52,7 @@ circuit Top : %[[
   {
     "class":"sifive.enterprise.grandcentral.MemTapAnnotation",
     "source": "~Top|Child>always",
-    "taps":["~Top|MemTap_2>_0", "~Top|MemTap_2>_1"]
+    "sink":["~Top|Top>tap_2[0]", "~Top|Top>tap_2[1]"]
   }
 ]]
   extmodule BlackBox :
@@ -56,18 +71,23 @@ circuit Top : %[[
     localparam.in <= io.in
     io.out <= localparam.out
 
-    mem always :
-      data-type => UInt<1>
-      depth => 2
-      read-latency => 0
-      write-latency => 1
-      writer => w
-      read-under-write => undefined
-    always.w.clk <= clock
-    always.w.en <= UInt<1>(1)
-    always.w.addr <= io.in
-    always.w.data <= io.in
-    always.w.mask <= UInt<1>(1)
+    cmem always : UInt<1>[2]
+
+    infer mport w = always[io.in], clock
+    w <= io.in
+
+    ; mem always :
+    ;   data-type => UInt<1>
+    ;   depth => 2
+    ;   read-latency => 0
+    ;   write-latency => 1
+    ;   writer => w
+    ;   read-under-write => undefined
+    ; always.w.clk <= clock
+    ; always.w.en <= UInt<1>(1)
+    ; always.w.addr <= io.in
+    ; always.w.data <= io.in
+    ; always.w.mask <= UInt<1>(1)
 
   module ChildWrapper :
     input clock : Clock
@@ -80,16 +100,6 @@ circuit Top : %[[
     signed.io.in <= io.in
     io.out <= signed.io.out
 
-  extmodule DataTap_2 :
-    output _1 : UInt<1>
-    output _0 : UInt<1>
-    defname = DataTap_2
-
-  extmodule MemTap_2 :
-    output _1 : UInt<1>
-    output _0 : UInt<1>
-    defname = MemTap_2
-
   module Top :
     input clock : Clock
     input reset : UInt<1>
@@ -100,53 +110,49 @@ circuit Top : %[[
     unsigned.reset <= reset
     wire in : UInt<1>
     wire out : UInt<1>
-    inst DataTap_2 of DataTap_2
-    DataTap_2._0 is invalid
-    DataTap_2._1 is invalid
     node _child_io_in_T = and(io.in, in)
     unsigned.io.in <= _child_io_in_T
     node _io_out_T = and(unsigned.io.out, out)
     io.out <= _io_out_T
-    inst MemTap_2 of MemTap_2
 
-    in <= or(DataTap_2._0, MemTap_2._0)
-    out <= or(DataTap_2._1, MemTap_2._1)
+    wire tap_0: UInt<1>
+    tap_0 is invalid
+
+    wire tap_1: UInt<1>
+    tap_1 is invalid
+
+    wire tap_2: UInt<1>[2]
+    tap_2 is invalid
 
-; CHECK: module DataTap_2_impl_0(
-; CHECK:   output _1,
-; CHECK:          _0);
-; CHECK:   assign _1 = Top.unsigned_0.signed_0.localparam_0.foo.bar.out;
-; CHECK:   assign _0 = Top.unsigned_0.signed_0.localparam_0.foo.bar.in;
-; CHECK: endmodule
+    in <= or(tap_0, tap_2[0])
+    out <= or(tap_1, tap_2[1])
 
-; CHECK: module MemTap_2_impl_0(
-; CHECK:   output  _1,
-; CHECK:           _0);
-; CHECK:   assign _1 = Top.unsigned_0.signed_0.always_ext.Memory[1];
-; CHECK:   assign _0 = Top.unsigned_0.signed_0.always_ext.Memory[0];
-; CHECK: endmodule
+; CHECK:      module Top
+; CHECK:        tap_0 = Top.unsigned_0.signed_0.localparam_0.foo.bar.in;
+; CHECK-NEXT:   tap_1 = Top.unsigned_0.signed_0.localparam_0.foo.bar.out;
+; CHECK-NEXT:   tap_2_0 = Top.unsigned_0.signed_0.always_ext.Memory[0];
+; CHECK-NEXT:   tap_2_1 = Top.unsigned_0.signed_0.always_ext.Memory[1];
 
 ; // -----
 
 circuit Top : %[[
   {
     "class": "sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox": "~Top|DataTap",
     "keys": [
       {
         "class": "sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source": "~Top|Top/foo:Foo>f",
-        "portName": "~Top|DataTap>b"
+        "sink": "~Top|Top>b"
       },
       {
         "class": "sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source": "~Top|Top/foo:Foo>g",
-        "portName": "~Top|DataTap>c"
+        "sink": "~Top|Top>c"
       },
       {
         "class": "sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source": "~Top|Top>k",
-        "portName": "~Top|DataTap>d"
+        "sink": "~Top|Top>d"
       }
     ]
   },
@@ -157,14 +163,12 @@ circuit Top : %[[
   {
     "class": "firrtl.transforms.DontTouchAnnotation",
     "target": "~Top|Top>inv"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Foo>g"
   }
 ]]
-  extmodule DataTap :
-    output b : UInt<1>
-    output c : UInt<1>
-    output d : UInt<1>
-    defname = DataTap
-
   module Foo :
     output g : UInt<1>
     wire inv: UInt<1>
@@ -177,37 +181,39 @@ circuit Top : %[[
     output io : { b : UInt<1>, c : UInt<1>, d: UInt<1> }
 
     inst foo of Foo
-    inst bar of Foo
-    inst dataTap of DataTap
     wire inv: UInt<1>
     inv is invalid
     wire k : UInt<1>
     k <= inv
-    io.b <= dataTap.b
-    io.c <= dataTap.c
-    io.d <= dataTap.d
-
-; CHECK: module DataTap_impl_0(
-; CHECK:   output b,
-; CHECK:          c,
-; CHECK:          d
-; CHECK: );
-; CHECK:   assign b = Top.foo.f;
-; CHECK:   assign c = Top.foo.g;
-; CHECK:   assign d = Top.k;
-; CHECK: endmodule
+
+    wire b: UInt<1>
+    b is invalid
+
+    wire c: UInt<1>
+    c is invalid
+
+    wire d: UInt<1>
+    d is invalid
+
+    io.b <= b
+    io.c <= c
+    io.d <= d
+
+    ; CHECK:      module Top
+    ; CHECK:        io_b = Top.foo.f;
+    ; CHECK-NEXT:   io_c = Top.foo.g;
+    ; CHECK-NEXT:   io_d = inv;
 
 ; // -----
 
 circuit TestHarness : %[[
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~TestHarness|DataTap",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~TestHarness|TestHarness/system:Top/test:Test>signal",
-        "portName":"~TestHarness|DataTap>_0"
+        "sink":"~TestHarness|Companion>tap_0"
       }
     ]
   },
@@ -225,131 +231,135 @@ circuit TestHarness : %[[
     inst test of Test
     inst Companion of Companion
     io <= Companion.io
-  extmodule DataTap :
-    output _0 : UInt<8>
-    defname = DataTap
   module Companion :
     output io : UInt<1>
-    inst DataTap of DataTap
-    io <= DataTap._0
+    wire tap_0: UInt<8>
+    tap_0 is invalid
+
+    io <= tap_0
   module Test :
     wire inv: UInt<1>
     inv is invalid
     wire signal : UInt<8>
     signal <= inv
 
-; CHECK:     module DataTap
-; CHECK-NOT: endmodule
-; CHECK:       assign _0 = Top.test.signal;
+; CHECK:       module Top(
+; CHECK-NOT:   endmodule
+; CHECK:         Companion Companion (
+; CHECK-NEXT:    .[[bore:[a-zA-Z0-9_]+]] (Top.test.signal)
+; CHECK:       endmodule
+
+; CHECK:       module Companion(
+; CHECK-NOT:   endmodule
+; CHECK-NEXT:    input [7:0] [[bore]]
+; CHECK:         io = [[bore]][0];
+; CHECK:       endmodule
 
 ; // -----
 
 circuit Top : %[[
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~Top|DataTap_Submodule",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "portName":"~Top|DataTap_Submodule>_0"
+        "sink":"~Top|Submodule>tap_0"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>wire_DUT",
-        "portName":"~Top|DataTap_Submodule>_1"
+        "sink":"~Top|Submodule>tap_1"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>wire_Top",
-        "portName":"~Top|DataTap_Submodule>_2"
+        "sink":"~Top|Submodule>tap_2"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "portName":"~Top|DataTap_Submodule>_3"
+        "sink":"~Top|Submodule>tap_3"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>port_DUT",
-        "portName":"~Top|DataTap_Submodule>_4"
+        "sink":"~Top|Submodule>tap_4"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>port_Top",
-        "portName":"~Top|DataTap_Submodule>_5"
+        "sink":"~Top|Submodule>tap_5"
       }
     ]
   },
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~Top|DataTap_DUT",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "portName":"~Top|DataTap_DUT>_0"
+        "sink":"~Top|DUT>tap_6"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>wire_DUT",
-        "portName":"~Top|DataTap_DUT>_1"
+        "sink":"~Top|DUT>tap_7"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>wire_Top",
-        "portName":"~Top|DataTap_DUT>_2"
+        "sink":"~Top|DUT>tap_8"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "portName":"~Top|DataTap_DUT>_3"
+        "sink":"~Top|DUT>tap_9"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>port_DUT",
-        "portName":"~Top|DataTap_DUT>_4"
+        "sink":"~Top|DUT>tap_10"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>port_Top",
-        "portName":"~Top|DataTap_DUT>_5"
+        "sink":"~Top|DUT>tap_11"
       }
     ]
   },
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~Top|DataTap_Top",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>wire_Submodule",
-        "portName":"~Top|DataTap_Top>_0"
+        "sink":"~Top|Top>tap_12[0]"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>wire_DUT",
-        "portName":"~Top|DataTap_Top>_1"
+        "sink":"~Top|Top>tap_12[1]"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>wire_Top",
-        "portName":"~Top|DataTap_Top>_2"
+        "sink":"~Top|Top>tap_12[2]"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT/submodule:Submodule>port_Submodule",
-        "portName":"~Top|DataTap_Top>_3"
+        "sink":"~Top|Top>tap_12[3]"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top/dut:DUT>port_DUT",
-        "portName":"~Top|DataTap_Top>_4"
+        "sink":"~Top|Top>tap_12[4]"
       },
       {
         "class":"sifive.enterprise.grandcentral.ReferenceDataTapKey",
         "source":"~Top|Top>port_Top",
-        "portName":"~Top|DataTap_Top>_5"
+        "sink":"~Top|Top>tap_12[5]"
       }
     ]
   },
@@ -364,33 +374,60 @@ circuit Top : %[[
   {
     "class": "firrtl.transforms.DontTouchAnnotation",
     "target": "~Top|Top>inv"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_0"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_1"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_2"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_3"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_4"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Submodule>tap_5"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_6"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_7"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_8"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_9"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_10"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|DUT>tap_11"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap_12"
   }
 ]]
-  extmodule DataTap_Submodule :
-    output _0 : UInt<1>
-    output _1 : UInt<1>
-    output _2 : UInt<1>
-    output _3 : UInt<1>
-    output _4 : UInt<1>
-    output _5 : UInt<1>
-
-
-  extmodule DataTap_DUT :
-    output _0 : UInt<1>
-    output _1 : UInt<1>
-    output _2 : UInt<1>
-    output _3 : UInt<1>
-    output _4 : UInt<1>
-    output _5 : UInt<1>
-
-  extmodule DataTap_Top :
-    output _0 : UInt<1>
-    output _1 : UInt<1>
-    output _2 : UInt<1>
-    output _3 : UInt<1>
-    output _4 : UInt<1>
-    output _5 : UInt<1>
-
   module Submodule :
     output port_Submodule: UInt<1>
     port_Submodule is invalid
@@ -401,8 +438,18 @@ circuit Top : %[[
     wire wire_Submodule: UInt<1>
     wire_Submodule <= inv
 
-    inst tap of DataTap_Submodule
-    port_Submodule <= or(tap._0, or(tap._1, or(tap._2, or(tap._3, or(tap._4, tap._5)))))
+    wire tap_0 : UInt<1>
+    wire tap_1 : UInt<1>
+    wire tap_2 : UInt<1>
+    wire tap_3 : UInt<1>
+    wire tap_4 : UInt<1>
+    wire tap_5 : UInt<1>
+    tap_0 is invalid
+    tap_1 is invalid
+    tap_2 is invalid
+    tap_3 is invalid
+    tap_4 is invalid
+    tap_5 is invalid
 
   module DUT :
     output port_DUT: UInt<1>
@@ -416,8 +463,18 @@ circuit Top : %[[
 
     inst submodule of Submodule
 
-    inst tap of DataTap_DUT
-    port_DUT <= or(tap._0, or(tap._1, or(tap._2, or(tap._3, or(tap._4, tap._5)))))
+    wire tap_6 : UInt<1>
+    wire tap_7 : UInt<1>
+    wire tap_8 : UInt<1>
+    wire tap_9 : UInt<1>
+    wire tap_10 : UInt<1>
+    wire tap_11 : UInt<1>
+    tap_6 is invalid
+    tap_7 is invalid
+    tap_8 is invalid
+    tap_9 is invalid
+    tap_10 is invalid
+    tap_11 is invalid
 
   module Top :
     output port_Top : UInt<1>
@@ -430,54 +487,53 @@ circuit Top : %[[
     wire_Top <= inv
 
     inst dut of DUT
-    inst tap of DataTap_Top
-    port_Top <= or(tap._0, or(tap._1, or(tap._2, or(tap._3, or(tap._4, tap._5)))))
-
-    ; CHECK:      module DataTap_Submodule
-    ; CHECK:      assign _0 = Submodule.wire_Submodule
-    ; CHECK-NEXT: assign _1 = DUT.wire_DUT
-    ; CHECK-NEXT: assign _2 = Top.wire_Top
-    ; CHECK:      assign _3 = Submodule.port_Submodule
-    ; CHECK-NEXT: assign _4 = DUT.port_DUT
-    ; CHECK-NEXT: assign _5 = Top.port_Top
-
-    ; CHECK: module DataTap_DUT
-    ; CHECK:      assign _0 = DUT.submodule.wire_Submodule
-    ; CHECK-NEXT: assign _1 = DUT.wire_DUT
-    ; CHECK-NEXT: assign _2 = Top.wire_Top
-    ; CHECK:      assign _3 = DUT.submodule.port_Submodule
-    ; CHECK-NEXT: assign _4 = DUT.port_DUT
-    ; CHECK-NEXT: assign _5 = Top.port_Top
-
-    ; CHECK: module DataTap_Top
-    ; CHECK:      assign _0 = Top.dut.submodule.wire_Submodule
-    ; CHECK-NEXT: assign _1 = Top.dut.wire_DUT
-    ; CHECK-NEXT: assign _2 = Top.wire_Top
-    ; CHECK:      assign _3 = Top.dut.submodule.port_Submodule
-    ; CHECK-NEXT: assign _4 = Top.dut.port_DUT
-    ; CHECK-NEXT: assign _5 = Top.port_Top
-
-; // -----
-
-circuit ConstantSinking : %[[
-  {
-    "class": "sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox": "~ConstantSinking|DataTap",
-    "keys": [
-      {
-        "class": "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-        "source": "~ConstantSinking|ConstantSinking>w",
-        "portName": "~ConstantSinking|DataTap>a"
-      }
-    ]
-  }
-]]
-  extmodule DataTap :
-    output a : UInt<1>
-
-  module ConstantSinking:
-    inst dataTap of DataTap
-    node w = UInt<1>(1)
+    wire tap_12 : UInt<1>[6]
+    tap_12 is invalid
+
+; CHECK-LABEL: module Submodule
+; CHECK-NEXT:    input [[Submodule_tap_1_port:[a-zA-Z0-9_]+]]
+; CHECK-NEXT:          [[Submodule_tap_2_port:[a-zA-Z0-9_]+]]
+; CHECK-NEXT:          [[Submodule_tap_5_port:[a-zA-Z0-9_]+]]
+;
+; CHECK-DAG:     tap_0 = wire_Submodule;
+; CHECK-DAG:     tap_1 = [[Submodule_tap_1_port]];
+; CHECK-DAG:     tap_2 = [[Submodule_tap_2_port]];
+; CHECK-DAG:     tap_3 = 1'h0;
+; CHECK-DAG:     tap_4 = 1'h0;
+; CHECK-DAG:     tap_5 = [[Submodule_tap_5_port]];
+
+; CHECK-LABEL: module DUT
+; CHECK-NEXT:    input [[DUT_tap_2_port:[a-zA-Z0-9_]+]]
+; CHECK-NEXT:          [[DUT_tap_5_port:[a-zA-Z0-9_]+]]
+; CHECK-NEXT:          [[DUT_tap_8_port:[a-zA-Z0-9_]+]]
+; CHECK-NEXT:          [[DUT_tap_11_port:[a-zA-Z0-9_]+]]
+;
+; CHECK-DAG:     tap_6 = DUT.submodule.wire_Submodule;
+; CHECK-DAG:     tap_7 = wire_DUT;
+; CHECK-DAG:     tap_8 = [[DUT_tap_8_port]];
+; CHECK-DAG:     tap_9 = 1'h0;
+; CHECK-DAG:     tap_10 = 1'h0;
+; CHECK-DAG:     tap_11 = [[DUT_tap_11_port]];
+;
+; CHECK:         Submodule submodule (
+; CHECK-DAG:       .[[Submodule_tap_1_port]] (wire_DUT)
+; CHECK-DAG:       .[[Submodule_tap_2_port]] ([[DUT_tap_2_port]])
+; CHECK-DAG:       .[[Submodule_tap_5_port]] ([[DUT_tap_5_port]])
+
+; CHECK-LABEL: module Top
+;
+; CHECK-DAG:     tap_12_0 = Top.dut.submodule.wire_Submodule
+; CHECK-DAG:     tap_12_1 = Top.dut.wire_DUT
+; CHECK-DAG:     tap_12_2 = inv;
+; CHECK-DAG:     tap_12_3 = 1'h0
+; CHECK-DAG:     tap_12_4 = 1'h0
+; CHECK-DAG:     tap_12_5 = 1'h0
+;
+; CHECK:         DUT dut (
+; CHECK-DAG:       .[[DUT_tap_2_port]] (inv)
+; CHECK-DAG:       .[[DUT_tap_5_port]] (1'h0)
+; CHECK-DAG:       .[[DUT_tap_8_port]] (inv)
+; CHECK-DAG:       .[[DUT_tap_11_port]] (1'h0)
 
 ; // -----
 
@@ -488,19 +544,18 @@ circuit Top : %[[
   },
   {
     "class":"sifive.enterprise.grandcentral.DataTapsAnnotation",
-    "blackBox":"~Top|DataTap",
     "keys":[
       {
         "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
         "module":"~Top|Child",
         "internalPath":"sum",
-        "portName":"~Top|DataTap>_0"
+        "sink":"~Top|Top>dt._0"
       },
       {
         "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
         "module":"~Top|Child",
         "internalPath":"not.a.real.path",
-        "portName":"~Top|DataTap>_1"
+        "sink":"~Top|Top>dt._1"
       }
     ]
   }
@@ -512,11 +567,6 @@ circuit Top : %[[
 
     io.out <= sum
 
-  extmodule DataTap :
-    output _0 : UInt<8>
-    output _1 : UInt<8>
-    defname = DataTap
-
   module Top :
     output io : { flip in : UInt<8>, out : UInt<8>}
     output taps : UInt<8>[2]
@@ -524,13 +574,14 @@ circuit Top : %[[
     inst child of Child
     io <= child.io
 
-    inst dt of DataTap
+    wire dt: {_0: UInt<8>, _1: UInt<8>}
+    dt is invalid
+
     taps[0] <= dt._0
     taps[1] <= dt._1
 
-; CHECK: module DataTap_impl_0(
-; CHECK:   output [7:0] _0,
-; CHECK:                _1);
-; CHECK:   assign _0 = Top.child.sum;
-; CHECK:   assign _1 = Top.child.not.a.real.path;
-; CHECK: endmodule
+; CHECK:     module Top(
+; CHECK-NOT: endmodule
+; CHECK:       taps_0 = Top.child.sum;
+; CHECK-NEXT:  taps_1 = Top.child.not.a.real.path;
+; CHECK:     endmodule
diff --git a/test/Dialect/FIRRTL/annotations-errors.mlir b/test/Dialect/FIRRTL/annotations-errors.mlir
index f2f2d7412..6c89af8a5 100644
--- a/test/Dialect/FIRRTL/annotations-errors.mlir
+++ b/test/Dialect/FIRRTL/annotations-errors.mlir
@@ -198,3 +198,44 @@ firrtl.circuit "DontTouchOnNonReferenceTarget" attributes {
     firrtl.instance submodule @Submodule()
   }
 }
+
+// -----
+
+// expected-error @+3 {{unknown/unimplemented DataTapKey class 'sifive.enterprise.grandcentral.DeletedDataTapKey'}}
+// expected-note  @+2 {{full Annotation is reproduced here}}
+// expected-error @+1 {{Unable to apply annotation}}
+firrtl.circuit "GCTDataTapUnsupportedDeleted" attributes {rawAnnotations = [{
+  blackBox = "~GCTDataTap|DataTap",
+  class = "sifive.enterprise.grandcentral.DataTapsAnnotation",
+  keys = [
+    {
+      class = "sifive.enterprise.grandcentral.DeletedDataTapKey",
+      sink = "~GCTDataTap|GCTDataTap>tap_1"
+    }
+  ]
+}]} {
+  firrtl.module @GCTDataTapUnsupportedDeleted() {
+    %tap = firrtl.wire : !firrtl.uint<1>
+  }
+}
+
+// -----
+
+// expected-error @+3 {{unknown/unimplemented DataTapKey class 'sifive.enterprise.grandcentral.LiteralDataTapKey'}}
+// expected-note  @+2 {{full Annotation is reproduced here}}
+// expected-error @+1 {{Unable to apply annotation}}
+firrtl.circuit "GCTDataTapUnsupportedLiteral" attributes {rawAnnotations = [{
+  blackBox = "~GCTDataTap|DataTap",
+  class = "sifive.enterprise.grandcentral.DataTapsAnnotation",
+  keys = [
+    {
+      class = "sifive.enterprise.grandcentral.LiteralDataTapKey",
+      literal = "UInt<16>(\22h2a\22)",
+      sink = "~GCTDataTap|GCTDataTap>tap"
+    }
+  ]
+}]} {
+  firrtl.module @GCTDataTapUnsupportedLiteral() {
+    %tap = firrtl.wire : !firrtl.uint<1>
+  }
+}
diff --git a/test/Dialect/FIRRTL/annotations.mlir b/test/Dialect/FIRRTL/annotations.mlir
index 419a1ce35..504befe84 100644
--- a/test/Dialect/FIRRTL/annotations.mlir
+++ b/test/Dialect/FIRRTL/annotations.mlir
@@ -1125,80 +1125,55 @@ firrtl.circuit "Foo"  attributes {rawAnnotations = [
 // Test sifive.enterprise.grandcentral.DataTapsAnnotation with all possible
 // variants of DataTapKeys.
 
+// SiFive-custom annotations related to the GrandCentral utility.  These
+// annotations do not conform to standard SingleTarget or NoTarget format and
+// need to be manually split up.
+
+// Test sifive.enterprise.grandcentral.DataTapsAnnotation with all possible
+// variants of DataTapKeys.
+
 firrtl.circuit "GCTDataTap" attributes {rawAnnotations = [{
-  blackBox = "~GCTDataTap|DataTap",
   class = "sifive.enterprise.grandcentral.DataTapsAnnotation",
   keys = [
     {
       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-      portName = "~GCTDataTap|DataTap>_0",
+      sink = "~GCTDataTap|GCTDataTap>tap_0",
       source = "~GCTDataTap|GCTDataTap>r"
     },
     {
       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-      portName = "~GCTDataTap|DataTap>_1[0]",
+      sink = "~GCTDataTap|GCTDataTap>tap_1[0]",
       source = "~GCTDataTap|GCTDataTap>r"
     },
     {
       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-      portName = "~GCTDataTap|DataTap>_2",
+      sink = "~GCTDataTap|GCTDataTap>tap_2",
       source = "~GCTDataTap|GCTDataTap>w.a"
     },
     {
       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-      portName = "~GCTDataTap|DataTap>_3[0]",
+      sink = "~GCTDataTap|GCTDataTap>tap_3[0]",
       source = "~GCTDataTap|GCTDataTap>w.a"
     },
     {
       class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey",
       internalPath = "baz.qux",
       module = "~GCTDataTap|BlackBox",
-      portName = "~GCTDataTap|DataTap>_4"
+      sink = "~GCTDataTap|GCTDataTap>tap_4"
     },
     {
       class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey",
       internalPath = "baz.quz",
       module = "~GCTDataTap|BlackBox",
-      portName = "~GCTDataTap|DataTap>_5[0]"
-    },
-    {
-      class = "sifive.enterprise.grandcentral.DeletedDataTapKey",
-      portName = "~GCTDataTap|DataTap>_6"
-    },
-    {
-      class = "sifive.enterprise.grandcentral.DeletedDataTapKey",
-      portName = "~GCTDataTap|DataTap>_7[0]"
-    },
-    {
-      class = "sifive.enterprise.grandcentral.LiteralDataTapKey",
-      literal = "UInt<16>(\22h2a\22)",
-      portName = "~GCTDataTap|DataTap>_8"
-    },
-    {
-      class = "sifive.enterprise.grandcentral.LiteralDataTapKey",
-      literal = "UInt<16>(\22h2a\22)",
-      portName = "~GCTDataTap|DataTap>_9[0]"
+      sink = "~GCTDataTap|GCTDataTap>tap_5[0]"
     },
     {
       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey",
-      portName = "~GCTDataTap|DataTap>_10",
+      sink = "~GCTDataTap|GCTDataTap>tap_6",
       source = "~GCTDataTap|GCTDataTap/im:InnerMod>w"
     }
   ]
 }]} {
-  firrtl.extmodule private @DataTap(
-    out _0: !firrtl.uint<1>,
-    out _1: !firrtl.vector<uint<1>, 1>,
-    out _2: !firrtl.uint<1>,
-    out _3: !firrtl.vector<uint<1>, 1>,
-    out _4: !firrtl.uint<1>,
-    out _5: !firrtl.vector<uint<1>, 1>,
-    out _6: !firrtl.uint<1>,
-    out _7: !firrtl.vector<uint<1>, 1>,
-    out _8: !firrtl.uint<1>,
-    out _9: !firrtl.vector<uint<1>, 1>,
-    out _10: !firrtl.uint<1>
-  ) attributes {defname = "DataTap"}
   firrtl.extmodule private @BlackBox() attributes {defname = "BlackBox"}
   firrtl.module private @InnerMod() {
     %w = firrtl.wire : !firrtl.uint<1>
@@ -1206,131 +1181,54 @@ firrtl.circuit "GCTDataTap" attributes {rawAnnotations = [{
   firrtl.module @GCTDataTap(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
     %r = firrtl.reg %clock  : !firrtl.uint<1>
     %w = firrtl.wire : !firrtl.bundle<a: uint<1>>
-    %DataTap__0, %DataTap__1, %DataTap__2, %DataTap__3, %DataTap__4, %DataTap__5, %DataTap__6, %DataTap__7, %DataTap__8, %DataTap__9, %DataTap__10 = firrtl.instance DataTap  @DataTap(out _0: !firrtl.uint<1>, out _1: !firrtl.vector<uint<1>, 1>, out _2: !firrtl.uint<1>, out _3: !firrtl.vector<uint<1>, 1>, out _4: !firrtl.uint<1>, out _5: !firrtl.vector<uint<1>, 1>, out _6: !firrtl.uint<1>, out _7: !firrtl.vector<uint<1>, 1>, out _8: !firrtl.uint<1>, out _9: !firrtl.vector<uint<1>, 1>, out _10: !firrtl.uint<1>)
+    %tap_0 = firrtl.wire : !firrtl.uint<1>
+    %tap_1 = firrtl.wire : !firrtl.vector<uint<1>, 1>
+    %tap_2 = firrtl.wire : !firrtl.uint<1>
+    %tap_3 = firrtl.wire : !firrtl.vector<uint<1>, 1>
+    %tap_4 = firrtl.wire : !firrtl.uint<1>
+    %tap_5 = firrtl.wire : !firrtl.vector<uint<1>, 1>
+    %tap_6 = firrtl.wire : !firrtl.uint<1>
+
     firrtl.instance BlackBox @BlackBox()
     firrtl.instance im @InnerMod()
   }
 }
 
-// CHECK-LABEL: firrtl.circuit "GCTDataTap"
-// CHECK:      hw.hierpath private [[NLA:@.+]] [@GCTDataTap::@im, @InnerMod]
-
-// CHECK-LABEL: firrtl.extmodule private @DataTap
-
-// CHECK-SAME: _0: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port"
-// CHECK-SAME:   id = [[ID:[0-9]+]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_0:[0-9]+]] : i64
-
-// CHECK-SAME: _1: !firrtl.vector<uint<1>, 1>
-// CHECK-SAME:   circt.fieldID = 1
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_1:[0-9]+]] : i64
-
-// CHECK-SAME: _2: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_2:[0-9]+]] : i64
-
-// CHECK-SAME: _3: !firrtl.vector<uint<1>, 1> [
-// CHECK-SAME:   circt.fieldID = 1
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_3:[0-9]+]] : i64
-
-// CHECK-SAME: _4: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_4:[0-9]+]] : i64
-
-// CHECK-SAME: _5: !firrtl.vector<uint<1>, 1>
-// CHECK-SAME:   circt.fieldID = 1
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_5:[0-9]+]] : i64
-
-// CHECK-SAME: _6: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.DeletedDataTapKey"
-// CHECK-SAME:   id = [[ID]] : i64
-
-// CHECK-SAME: _7: !firrtl.vector<uint<1>, 1>
-// CHECK-SAME:   circt.fieldID = 1
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.DeletedDataTapKey"
-// CHECK-SAME:   id = [[ID]] : i64
-
-// CHECK-SAME: _8: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.LiteralDataTapKey"
-// CHECK-SAME:   literal = "UInt<16>(\22h2a\22)"
-
-// CHECK-SAME: _9: !firrtl.vector<uint<1>, 1>
-// CHECK-SAME:   circt.fieldID = 1
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.LiteralDataTapKey"
-// CHECK-SAME:   literal = "UInt<16>(\22h2a\22)"
-
-// CHECK-SAME: _10: !firrtl.uint<1>
-// CHECK-SAME:   class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port"
-// CHECK-SAME:   id = [[ID]] : i64
-// CHECK-SAME:   portID = [[PORT_ID_6:[0-9]+]] : i64
-
-// CHECK-SAME: annotations = [
-// CHECK-SAME:   {class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"}
-// CHECK-SAME: ]
-
 // CHECK-LABEL: firrtl.extmodule private @BlackBox
-// CHECK-SAME: annotations = [
-// CHECK-SAME:   {
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.source",
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     internalPath = "baz.quz",
-// CHECK-SAME:     portID = [[PORT_ID_5]] : i64
-// CHECK-SAME:   }
-// CHECK-SAME:   {
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.source",
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     internalPath = "baz.qux",
-// CHECK-SAME:     portID = [[PORT_ID_4]] : i64
-// CHECK-SAME:   }
-// CHECK-SAME: ]
+// CHECK-SAME:    out [[tap_4:[a-zA-Z0-9_]+]]: !firrtl.ref<uint<1>>
+// CHECk-SAME:    out [[tap_5_0:[[a-zA-Z09-_]+]]]: !firrtl.ref<uint<1>>
+// CHECK-SAME:    internalPaths = ["baz.qux", "baz.quz"]
 
 // CHECK-LABEL: firrtl.module private @InnerMod
-// CHECK-NEXT: %w = firrtl.wire
-// CHECK-NOT:  sym
-// CHECK-SAME: annotations = [
-// CHECK-SAME:   {
-// CHECK-SAME:     circt.nonlocal = [[NLA]]
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     portID = [[PORT_ID_6]]
-// CHECK-SAME:   }
-// CHECK-SAME: ]
-
-// CHECK: firrtl.module @GCTDataTap
-// CHECK-LABEL: firrtl.reg
-// CHECK-NOT:  sym
-// CHECk-SAME: annotations = [
-// CHECK-SAME:   {
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     portID = [[PORT_ID_0]]
-// CHECK-SAME:   }
-// CHECK-SAME: ]
-
-// CHECK-LABEL: firrtl.wire
-// CHECK-NOT:  sym
-// CHECK-SAME: annotations = [
-// CHECK-SAME:   {
-// CHECK-SAME:     circt.fieldID = 1
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     portID = [[PORT_ID_3]]
-// CHECK-SAME:   }
-// CHECK-SAME:   {
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-// CHECK-SAME:      id = [[ID]]
-// CHECK-SAME:      portID = [[PORT_ID_2]]
-// CHECK-SAME:   }
-// CHECK-SAME: ]
+// CHECK-SAME:    out %[[tap_6:[a-zA-Z0-9_]+]]: !firrtl.ref<uint<1>>
+// CHECK:         %[[w_ref:[a-zA-Z09_]+]] = firrtl.ref.send %w
+// CHECK:         firrtl.connect %[[tap_6]], %[[w_ref]]
+
+// CHECK-LABEL: firrtl.module @GCTDataTap
+// CHECK:         %[[w_a0:[a-zA-Z0-9_]+]] = firrtl.subfield %w[a]
+// CHECK-NEXT:    %[[w_a1:[a-zA-Z0-9_]+]] = firrtl.subfield %w[a]
+//
+// CHECK-DAG:    %tap_0 = firrtl.node %r
+//
+// CHECK-DAG:    %[[tap_1_0:[a-zA-Z0-9_]+]] = firrtl.subindex %tap_1[0]
+// CHECK-DAG:    firrtl.connect %[[tap_1_0]], %r
+//
+// CHECK-DAG:    %tap_2 = firrtl.node %[[w_a1]]
+//
+// CHECK-DAG:    %[[tap_3_0:[a-zA-Z0-9_]+]] = firrtl.subindex %tap_3[0]
+// CHECK-DAG:    firrtl.connect %[[tap_3_0]], %[[w_a0]]
+//
+// CHECK-DAG:    %[[tap_4_port:[a-zA-Z0-9_]+]], %[[tap_5_port:[a-zA-Z0-9_]+]] = firrtl.instance BlackBox
+// CHECK-DAG:    %[[tap_4_resolve:[a-zA-Z0-9_]+]] = firrtl.ref.resolve %[[tap_4_port]]
+// CHECK-DAG:    %tap_4 = firrtl.node %[[tap_4_resolve]]
+//
+// CHECK-DAG:    %[[tap_5_resolve:[a-zA-Z0-9_]+]] = firrtl.ref.resolve %[[tap_5_port]]
+// CHECK-DAG:    %[[tap_5_0:[a-zA-Z0-9_]+]] = firrtl.subindex %tap_5[0]
+// CHECK-DAG:    firrtl.connect %[[tap_5_0]], %[[tap_5_resolve]]
+//
+// CHECK-DAG:    %[[tap_6_port:[a-zA-Z0-9_]+]] = firrtl.instance im @InnerMod
+// CHECK-DAG:    %[[tap_6_resolve:[a-zA-Z0-9_]+]] = firrtl.ref.resolve %[[tap_6_port]]
+// CHECK-DAG:    %tap_6 = firrtl.node %[[tap_6_resolve]]
 
 // -----
 
@@ -1338,48 +1236,23 @@ firrtl.circuit "GCTDataTap" attributes {rawAnnotations = [{
 firrtl.circuit "GCTMemTap" attributes {rawAnnotations = [{
   class = "sifive.enterprise.grandcentral.MemTapAnnotation",
   source = "~GCTMemTap|GCTMemTap>mem",
-  taps = ["GCTMemTap.MemTap.mem[0]", "GCTMemTap.MemTap.mem[1]"]
+  sink = ["GCTMemTap.GCTMemTap.memTap[0]", "~GCTMemTap|GCTMemTap>mem[1]"]
 }]} {
-  firrtl.extmodule private @MemTap(out mem: !firrtl.vector<uint<1>, 2>) attributes {defname = "MemTap"}
-  firrtl.module @GCTMemTap(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>) {
+  firrtl.module @GCTMemTap() {
     %mem = chirrtl.combmem  : !chirrtl.cmemory<uint<1>, 2>
-    %MemTap_mem = firrtl.instance MemTap  @MemTap(out mem: !firrtl.vector<uint<1>, 2>)
-    %0 = firrtl.subindex %MemTap_mem[1] : !firrtl.vector<uint<1>, 2>
-    %1 = firrtl.subindex %MemTap_mem[0] : !firrtl.vector<uint<1>, 2>
-    %memTap = firrtl.wire  : !firrtl.vector<uint<1>, 2>
-    %2 = firrtl.subindex %memTap[1] : !firrtl.vector<uint<1>, 2>
-    %3 = firrtl.subindex %memTap[0] : !firrtl.vector<uint<1>, 2>
-    firrtl.strictconnect %3, %1 : !firrtl.uint<1>
-    firrtl.strictconnect %2, %0 : !firrtl.uint<1>
+    %memTap = firrtl.wire : !firrtl.vector<uint<1>, 2>
   }
 }
 
 
 // CHECK-LABEL: firrtl.circuit "GCTMemTap"
 
-// CHECK-LABEL: firrtl.extmodule private @MemTap
-// CHECK-SAME: mem: !firrtl.vector<uint<1>, 2> [
-// CHECK-SAME:   {
-// CHECK-SAME:     circt.fieldID = 2
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.MemTapAnnotation.port"
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:     portID = 1
-// CHECK-SAME:   }
-// CHECK-SAME:   {
-// CHECK-SAME:     circt.fieldID = 1
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.MemTapAnnotation.port"
-// CHECK-SAME:     id = [[ID:[0-9]+]] : i64
-// CHECK-SAME:     portID = 0
-// CHECK-SAME:   }
-
-// CHECK-LABEL: firrtl.module @GCTMemTap
-// CHECK: %mem = chirrtl.combmem
-// CHECK-SAME: annotations = [
-// CHECK-SAME:   {
-// CHECK-SAME:     class = "sifive.enterprise.grandcentral.MemTapAnnotation.source"
-// CHECK-SAME:     id = [[ID]]
-// CHECK-SAME:   }
-// CHECK-SAME: ]
+// CHECK:      firrtl.module @GCTMemTap
+// CHECK:        %[[debug_port:[a-zA-Z0-9_]+]] = chirrtl.debugport %mem
+// CHECK-SAME:     {name = "memTap"}
+// CHECK-SAME:     (!chirrtl.cmemory<uint<1>, 2>) -> !firrtl.ref<vector<uint<1>, 2>>
+// CHECK-NEXT:   %[[debug_port_resolve:[a-zA-Z0-9_]+]] = firrtl.ref.resolve %[[debug_port]]
+// CHECK-NEXT:   %memTap = firrtl.node %[[debug_port_resolve]]
 
 // -----
 
diff --git a/test/Dialect/FIRRTL/grand-central-taps.mlir b/test/Dialect/FIRRTL/grand-central-taps.mlir
deleted file mode 100644
index eefb2db7c..000000000
--- a/test/Dialect/FIRRTL/grand-central-taps.mlir
+++ /dev/null
@@ -1,639 +0,0 @@
-// RUN: circt-opt %s --firrtl-grand-central-taps --symbol-dce --split-input-file | FileCheck %s
-
-firrtl.circuit "TestHarness" attributes {
-  annotations = [{
-    class = "sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation",
-    directory = "outputDirectory",
-    filename = "bindings.sv"
-  }]
-} {
-  // CHECK: firrtl.module private @Bar
-  // CHECK-SAME: in %clock: !firrtl.clock sym [[BAR_CLOCK:@[0-9a-zA-Z_]+]]
-  // CHECK-SAME: in %reset: !firrtl.reset sym [[BAR_RESET:@[0-9a-zA-Z_]+]]
-  // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-  firrtl.module private @Bar(
-    in %clock: !firrtl.clock,
-    in %reset: !firrtl.reset,
-    in %in: !firrtl.uint<1>,
-    out %out: !firrtl.uint<1>
-  ) attributes
-   {portAnnotations = [ [ {
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 2 : i64
-    }], [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 3 : i64
-    } ],[],[] ] }
-  {
-    // CHECK: %wire = firrtl.wire sym [[WIRE:@[0-9a-zA-Z_]+]]
-    // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-    // CHECK-SAME: class = "firrtl.transforms.DontTouchAnnotation"
-    %wire = firrtl.wire {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 1 : i64
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.uint<1>
-
-    // CHECK: %node = firrtl.node sym [[NODE:@[0-9a-zA-Z_]+]]
-    // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-    // CHECK-SAME: class = "firrtl.transforms.DontTouchAnnotation"
-    %node = firrtl.node %in {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 5 : i64
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.uint<1>
-
-    // CHECK: %reg = firrtl.reg sym [[REG:@[0-9a-zA-Z_]+]]
-    // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-    // CHECK-SAME: class = "firrtl.transforms.DontTouchAnnotation"
-    %reg = firrtl.reg %clock {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 6 : i64
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.uint<1>
-
-    // CHECK: %regreset = firrtl.regreset sym [[REGRESET:@[0-9a-zA-Z_]+]]
-    // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-    // CHECK-SAME: class = "firrtl.transforms.DontTouchAnnotation"
-    %regreset = firrtl.regreset %clock, %reset, %in {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 7 : i64
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.reset, !firrtl.uint<1>, !firrtl.uint<1>
-
-    %array = firrtl.wire {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 12 : i64,
-      circt.fieldID = 2
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.vector<uint<1>, 2>
-
-    %mem_0 = firrtl.reg %clock  {annotations = [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 4 : i64, portID = 0 : i64}, {class = "firrtl.transforms.DontTouchAnnotation"}]} : !firrtl.uint<1>
-    %mem_1 = firrtl.reg %clock  {annotations = [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 4 : i64, portID = 1 : i64}, {class = "firrtl.transforms.DontTouchAnnotation"}]} : !firrtl.uint<1>
-    // CHECK:   %mem_0 = firrtl.reg sym @[[gct_sym_5:.+]] %clock  {annotations = [{class = "firrtl.transforms.DontTouchAnnotation"}]} : !firrtl.uint<1>
-    // CHECK:   %mem_1 = firrtl.reg sym @[[gct_sym_6:.+]] %clock  {annotations = [{class = "firrtl.transforms.DontTouchAnnotation"}]} : !firrtl.uint<1>
-    %mem = firrtl.mem Undefined {
-      annotations = [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 42 : i64}],
-      name = "mem",
-      depth = 2 : i64,
-      portNames = ["MPORT"],
-      readLatency = 0 : i32,
-      writeLatency = 1 : i32
-    } : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    // CHECK: firrtl.mem sym @[[gct_sym_7:.+]] Undefined
-    %mem_addr = firrtl.subfield %mem[addr] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %mem_en = firrtl.subfield %mem[en] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %mem_clk = firrtl.subfield %mem[clk] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    firrtl.connect %mem_addr, %in : !firrtl.uint<1>, !firrtl.uint<1>
-    firrtl.connect %mem_en, %in : !firrtl.uint<1>, !firrtl.uint<1>
-    firrtl.connect %mem_clk, %clock : !firrtl.clock, !firrtl.clock
-
-    %42 = firrtl.not %in : (!firrtl.uint<1>) -> !firrtl.uint<1>
-    firrtl.connect %wire, %42  : !firrtl.uint<1>, !firrtl.uint<1>
-    firrtl.connect %out, %wire : !firrtl.uint<1>, !firrtl.uint<1>
-  }
-
-  firrtl.module private @Foo(
-    in %clock: !firrtl.clock,
-    in %reset: !firrtl.reset,
-    in %in: !firrtl.uint<1>,
-    out %out: !firrtl.uint<1>
-  ) {
-    // CHECK: firrtl.instance bar sym [[BAR:@[0-9a-zA-Z_]+]]
-    %bar_clock, %bar_reset, %bar_in, %bar_out = firrtl.instance bar @Bar(in clock: !firrtl.clock, in reset: !firrtl.reset, in in: !firrtl.uint<1>, out out: !firrtl.uint<1>)
-    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock
-    firrtl.connect %bar_reset, %reset : !firrtl.reset, !firrtl.reset
-    firrtl.connect %bar_in, %in : !firrtl.uint<1>, !firrtl.uint<1>
-    firrtl.connect %out, %bar_out : !firrtl.uint<1>, !firrtl.uint<1>
-  }
-
-  // CHECK: firrtl.module private @[[DT:DataTap.*]](
-  // CHECK-SAME: out %_10: !firrtl.uint<4>
-  // CHECK-SAME: out %_9: !firrtl.uint<1>
-  // CHECK-SAME: out %_8: !firrtl.sint<8>
-  // CHECK-SAME: out %_7: !firrtl.uint<1>
-  // CHECK-SAME: out %_6: !firrtl.uint<1>
-  // CHECK-SAME: out %_5: !firrtl.uint<1>
-  // CHECK-SAME: out %_4: !firrtl.uint<1>
-  // CHECK-SAME: out %_3: !firrtl.uint<1>
-  // CHECK-SAME: out %_2: !firrtl.uint<1>
-  // CHECK-SAME: out %_1: !firrtl.clock
-  // CHECK-SAME: out %_0: !firrtl.uint<1>
-  // CHECK-SAME: #hw.output_file<"outputDirectory{{/|\\\\}}[[DT]].sv">
-  // CHECK-NEXT: [[V11:%.+]] = firrtl.verbatim.expr
-  // CHECK-SAME{LITERAL}: "{{0}}.{{1}}.{{2}}.{{3}}[1]"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[HARNESSWIRE:@[0-9a-zA-Z_]+]]>
-  // CHECK-NEXT: firrtl.connect %_11, [[V11]]
-  // CHECK-NEXT: [[V10:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[HARNESSWIRE:@[0-9a-zA-Z_]+]]>
-  // CHECK-NEXT: firrtl.connect %_10, [[V10]]
-  // CHECK-NEXT: [[V9:%.+]] = firrtl.constant 0 : !firrtl.uint<1>
-  // CHECK-NEXT: firrtl.connect %_9, [[V9]]
-  // CHECK-NEXT: [[V8:%.+]] = firrtl.constant -42 : !firrtl.sint<8>
-  // CHECK-NEXT: firrtl.connect %_8, [[V8]]
-  // CHECK-NEXT: [[V7:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[EXTMODULEWITHTAPPEDPORT:@[0-9a-zA-Z_]+]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@ExtmoduleWithTappedPort::[[EXTMODULEWITHTAPPEDPORTOUT:@[0-9a-zA-Z_]+]]>
-  // CHECK-NEXT: firrtl.connect %_7, [[V7]]
-  // CHECK-NEXT: [[V6:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO:@[0-9a-zA-Z_]+]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[REGRESET]]>
-  // CHECK-NEXT: firrtl.connect %_6, [[V6]]
-  // CHECK-NEXT: [[V5:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[REG]]>
-  // CHECK-NEXT: firrtl.connect %_5, [[V5]]
-  // CHECK-NEXT: [[V4:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[NODE]]>
-  // CHECK-NEXT: firrtl.connect %_4, [[V4]]
-  // CHECK-NEXT: [[V3:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.schwarzschild.no.more"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[BIGSCARY:@[0-9a-zA-Z_]+]]>
-  // CHECK-NEXT: firrtl.connect %_3, [[V3]]
-  // CHECK-NEXT: [[V2:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[BAR_RESET]]>
-  // CHECK-NEXT: firrtl.connect %_2, [[V2]]
-  // CHECK-NEXT: [[V1:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[BAR_CLOCK]]>
-  // CHECK-NEXT: firrtl.connect %_1, [[V1]]
-  // CHECK-NEXT: [[V0:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::[[WIRE]]>
-  // CHECK-NEXT: firrtl.connect %_0, [[V0]]
-  firrtl.extmodule private @DataTap(
-    out _11: !firrtl.uint<1>,
-    out _10: !firrtl.uint<4>,
-    out _9: !firrtl.uint<1>,
-    out _8: !firrtl.sint<8>,
-    out _7: !firrtl.uint<1>,
-    out _6: !firrtl.uint<1>,
-    out _5: !firrtl.uint<1>,
-    out _4: !firrtl.uint<1>,
-    out _3: !firrtl.uint<1>,
-    out _2: !firrtl.uint<1>,
-    out _1: !firrtl.clock,
-    out _0: !firrtl.uint<1>
-  ) attributes {
-    annotations = [
-      { class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox" },
-      { class = "firrtl.transforms.NoDedupAnnotation" }
-    ],
-    portAnnotations = [
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 12 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 11 : i64}],
-      [{class = "sifive.enterprise.grandcentral.LiteralDataTapKey", literal = "UInt<1>(\"h0\")", id = 0 : i64, portID = 10 : i64 }],
-      [{class = "sifive.enterprise.grandcentral.LiteralDataTapKey", literal = "SInt<8>(\"h-2A\")", id = 0 : i64, portID = 9 : i64 }],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 8 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 7 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 6 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 5 : i64}],
-      [{class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.port", id = 0 : i64, portID = 4 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 3 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 2 : i64}],
-      [{class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port", id = 0 : i64, portID = 1 : i64}]
-    ],
-    defname = "DataTap"
-  }
-
-  // CHECK: firrtl.module private @[[MT:MemTap.*]](
-  // CHECK-NOT: class = "sifive.enterprise.grandcentral.MemTapAnnotation.port"
-  // CHECK-SAME: out %mem_0: !firrtl.uint<1>
-  // CHECK-SAME: out %mem_1: !firrtl.uint<1>
-  // CHECK-SAME: class = "firrtl.transforms.NoDedupAnnotation"
-  // CHECK-SAME: #hw.output_file<"outputDirectory{{/|\\\\}}[[MT]].sv">
-  // CHECK-NEXT: [[V0:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::@[[gct_sym_5]]>
-  // CHECK-NEXT: firrtl.connect %mem_0, [[V0:%.+]]
-  // CHECK-NEXT: [[V1:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::@[[gct_sym_6]]>
-  // CHECK-NEXT: firrtl.connect %mem_1, [[V1:%.+]]
-  firrtl.extmodule private @MemTap(
-    out mem_0: !firrtl.uint<1>,
-    out mem_1: !firrtl.uint<1>
-  ) attributes {
-    annotations = [
-      {class = "firrtl.transforms.NoDedupAnnotation"}
-    ],
-    portAnnotations = [
-      [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 4 : i64, portID = 0 : i64}],
-      [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 4 : i64, portID = 1 : i64}]
-    ],
-    defname = "MemTap"
-  }
-
-  // CHECK: firrtl.module private @[[MT2:MemTap2.*]](
-  // CHECK-NOT: class = "sifive.enterprise.grandcentral.MemTapAnnotation.port"
-  // CHECK-SAME: out %mem_0: !firrtl.uint<1>
-  // CHECK-SAME: out %mem_1: !firrtl.uint<1>
-  // CHECK-SAME: class = "firrtl.transforms.NoDedupAnnotation"
-  // CHECK-SAME: #hw.output_file<"outputDirectory{{/|\\\\}}[[MT2]].sv">
-  // CHECK-NEXT: [[V0:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}.Memory[0]"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::@[[gct_sym_7]]>
-  // CHECK-NEXT: firrtl.connect %mem_0, [[V0:%.+]]
-  // CHECK-NEXT: [[V1:%.+]] = firrtl.verbatim.expr "{{[{][{]0[}][}]}}.{{[{][{]1[}][}]}}.{{[{][{]2[}][}]}}.{{[{][{]3[}][}]}}.Memory[1]"
-  // CHECK-SAME:   @TestHarness,
-  // CHECK-SAME:   #hw.innerNameRef<@TestHarness::[[FOO]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Foo::[[BAR]]>,
-  // CHECK-SAME:   #hw.innerNameRef<@Bar::@[[gct_sym_7]]>
-  // CHECK-NEXT: firrtl.connect %mem_1, [[V1:%.+]]
-  firrtl.extmodule private @MemTap2(
-    out mem_0: !firrtl.uint<1>,
-    out mem_1: !firrtl.uint<1>
-  ) attributes {
-    annotations = [
-      {class = "firrtl.transforms.NoDedupAnnotation"}
-    ],
-    portAnnotations = [
-      [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 42 : i64, portID = 0 : i64}],
-      [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 42 : i64, portID = 1 : i64}]
-    ],
-    defname = "MemTap2"
-  }
-
-  // CHECK-LABEL: firrtl.extmodule private @BlackHole()
-  // CHECK-NOT: class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.source"
-  firrtl.extmodule private @BlackHole() attributes {
-    annotations = [{
-      class = "sifive.enterprise.grandcentral.DataTapModuleSignalKey.source",
-      internalPath = "schwarzschild.no.more",
-      id = 0 : i64,
-      portID = 4 : i64 }]
-  }
-
-  // CHECK-LABEL: firrtl.extmodule private @ExtmoduleWithTappedPort
-  // CHECK-SAME: out out: !firrtl.uint<1> sym [[EXTMODULEWITHTAPPEDPORTOUT]]
-  firrtl.extmodule private @ExtmoduleWithTappedPort(
-    out out: !firrtl.uint<1>) attributes {portAnnotations = [[{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 8 : i64}]]}
-
-  // CHECK: firrtl.module @TestHarness
-  firrtl.module @TestHarness(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, in %in: !firrtl.uint<1>, out %out: !firrtl.uint<1>) {
-    // CHECK: %harnessWire = firrtl.wire sym [[HARNESSWIRE]]
-    // CHECK-NOT: class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source"
-    // CHECK-SAME: class = "firrtl.transforms.DontTouchAnnotation"
-    %harnessWire = firrtl.wire {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 11 : i64
-    }, {
-      class = "firrtl.transforms.DontTouchAnnotation"
-    }]} : !firrtl.uint<4>
-
-    // CHECK: firrtl.instance foo sym [[FOO]]
-    %foo_clock, %foo_reset, %foo_in, %foo_out = firrtl.instance foo @Foo(in clock: !firrtl.clock, in reset: !firrtl.reset, in in: !firrtl.uint<1>, out out: !firrtl.uint<1>)
-    firrtl.connect %foo_clock, %clock : !firrtl.clock, !firrtl.clock
-    firrtl.connect %foo_reset, %reset : !firrtl.reset, !firrtl.uint<1>
-    firrtl.connect %foo_in, %in : !firrtl.uint<1>, !firrtl.uint<1>
-    firrtl.connect %out, %foo_out : !firrtl.uint<1>, !firrtl.uint<1>
-    // CHECK: firrtl.instance bigScary sym [[BIGSCARY]]
-    firrtl.instance bigScary @BlackHole()
-    // CHECK: firrtl.instance extmoduleWithTappedPort sym [[EXTMODULEWITHTAPPEDPORT]]
-    %0 = firrtl.instance extmoduleWithTappedPort @ExtmoduleWithTappedPort(out out: !firrtl.uint<1>)
-    // CHECK: firrtl.instance dataTap @[[DT]]
-    %DataTap_11, %DataTap_10, %DataTap_9, %DataTap_8, %DataTap_7, %DataTap_6, %DataTap_5, %DataTap_4, %DataTap_3, %DataTap_2, %DataTap_1, %DataTap_0 = firrtl.instance dataTap @DataTap(out _11: !firrtl.uint<1>, out _10: !firrtl.uint<4>, out _9: !firrtl.uint<1>, out _8: !firrtl.sint<8>, out _7: !firrtl.uint<1>, out _6: !firrtl.uint<1>, out _5: !firrtl.uint<1>, out _4: !firrtl.uint<1>, out _3: !firrtl.uint<1>, out _2: !firrtl.uint<1>, out _1: !firrtl.clock, out _0: !firrtl.uint<1>)
-    // CHECK: firrtl.instance memTap @[[MT]]
-    // CHECK: firrtl.instance memTap2 @[[MT2]]
-    %MemTap_mem_0, %MemTap_mem_1 = firrtl.instance memTap @MemTap(out mem_0: !firrtl.uint<1>, out mem_1: !firrtl.uint<1>)
-    %MemTap2_mem_0, %MemTap2_mem_1 = firrtl.instance memTap2 @MemTap2(out mem_0: !firrtl.uint<1>, out mem_1: !firrtl.uint<1>)
-  }
-}
-
-// -----
-
-// Test that NLAs are properly garbage collected.  After this runs, no NLAs
-// should exist in the circuit.
-//
-// CHECK-LABEL: firrtl.circuit "NLAGarbageCollection"
-firrtl.circuit "NLAGarbageCollection" {
-  // CHECK-NOT: @nla_1
-  // CHECK-NOT: @nla_2
-  // CHECK-NOT: @nla_3
-  hw.hierpath private @nla_1 [@NLAGarbageCollection::@dut, @DUT::@submodule, @Submodule::@foo]
-  hw.hierpath private @nla_2 [@NLAGarbageCollection::@dut, @DUT::@submodule, @Submodule::@port]
-  hw.hierpath private @nla_3 [@NLAGarbageCollection::@dut, @DUT::@submodule, @Submodule::@bar_0]
-  firrtl.module private @Submodule(
-    in %port: !firrtl.uint<1> sym @port [
-      {circt.nonlocal = @nla_2,
-       class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-       id = 1 : i64,
-       portID = 3 : i64}]
-  ) {
-    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>
-    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
-    %foo = firrtl.wire sym @foo {
-      annotations = [
-        {circt.nonlocal = @nla_1,
-         class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-         id = 1 : i64,
-         portID = 2 : i64}]} : !firrtl.uint<1>
-    %bar_out_MPORT_clk = firrtl.wire  : !firrtl.clock
-    %bar_0 = firrtl.reg sym @bar_0 %bar_out_MPORT_clk  {annotations = [{circt.nonlocal = @nla_3, class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 0 : i64, portID = 0 : i64}]} : !firrtl.uint<1>
-    // CHECK:  %bar_0 = firrtl.reg sym @[[bar_0:.+]] %bar_out_MPORT_clk  : !firrtl.uint<1>
-    %bar_out_MPORT = firrtl.mem Undefined {
-      depth = 1 : i64,
-      name = "bar",
-      portNames = ["out_MPORT"],
-      readLatency = 0 : i32,
-      writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-  }
-  firrtl.extmodule private @MemTap(
-    out mem_0: !firrtl.uint<1> [
-      {class = "sifive.enterprise.grandcentral.MemTapAnnotation.port",
-       id = 0 : i64,
-       portID = 0 : i64}]
-  ) attributes {
-    annotations = [
-      {class = "firrtl.transforms.NoDedupAnnotation"}],
-    defname = "MemTap"
-  }
-  firrtl.extmodule private @DataTap_1(
-    out _1: !firrtl.uint<1> sym @_1 [
-      {class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-       id = 1 : i64,
-       portID = 3 : i64}],
-    out _0: !firrtl.uint<1> sym @_0 [
-      {class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-       id = 1 : i64,
-       portID = 2 : i64}]
-  ) attributes {
-    annotations = [
-      {class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"},
-      {class = "firrtl.transforms.DontTouchAnnotation"},
-      {class = "firrtl.transforms.NoDedupAnnotation"}],
-    defname = "DataTap_1"}
-  firrtl.module private @DUT() attributes {
-    annotations = [
-      {class = "sifive.enterprise.firrtl.MarkDUTAnnotation"}
-    ]
-  } {
-    %submodule_port = firrtl.instance submodule sym @submodule @Submodule(in port : !firrtl.uint<1>)
-    %MemTap_0 = firrtl.instance mem_tap_MemTap  @MemTap(out mem_0: !firrtl.uint<1>)
-    %DataTap_0, %DataTap_1 = firrtl.instance DataTap_1  @DataTap_1(out _1: !firrtl.uint<1>, out _0: !firrtl.uint<1>)
-  }
-  firrtl.module @NLAGarbageCollection() {
-    firrtl.instance dut sym @dut @DUT()
-  }
-}
-
-// -----
-
-// Check that NLAs are used to wire up the data tap port connections properly.
-// See https://github.com/llvm/circt/issues/2691.
-
-// CHECK-LABEL: firrtl.circuit "NLAUsedInWiring"
-firrtl.circuit "NLAUsedInWiring"  {
-  // CHECK-NOT: @nla_1
-  // CHECK-NOT: @nla_2
-  hw.hierpath private @nla_1 [@NLAUsedInWiring::@foo, @Foo::@f]
-  hw.hierpath private @nla_2 [@NLAUsedInWiring::@foo, @Foo::@g]
-
-  // CHECK-LABEL: firrtl.module private @DataTap
-  // CHECK-NEXT: [[TMP:%.+]] = firrtl.verbatim.expr
-  // CHECK-SAME:   symbols = [@NLAUsedInWiring, #hw.innerNameRef<@NLAUsedInWiring::@foo>, #hw.innerNameRef<@Foo::@f>]
-  // CHECK-NEXT: firrtl.connect %b, [[TMP]] : !firrtl.uint<1>, !firrtl.uint<1>
-  // CHECK-NEXT: [[TMP:%.+]] = firrtl.verbatim.expr
-  // CHECK-SAME:   symbols = [@NLAUsedInWiring, #hw.innerNameRef<@NLAUsedInWiring::@foo>, #hw.innerNameRef<@Foo::@g>]
-  // CHECK-NEXT: firrtl.connect %c, [[TMP]] : !firrtl.uint<1>, !firrtl.uint<1>
-  // CHECK-NEXT: [[TMP:%.+]] = firrtl.verbatim.expr
-  // CHECK-SAME:   symbols = [@NLAUsedInWiring, #hw.innerNameRef<@NLAUsedInWiring::@k>]
-  // CHECK-NEXT: firrtl.connect %d, [[TMP]] : !firrtl.uint<1>, !firrtl.uint<1>
-  firrtl.extmodule private @DataTap(
-    out b: !firrtl.uint<1> sym @b [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-      id = 0 : i64,
-      portID = 1 : i64
-    }],
-    out c: !firrtl.uint<1> sym @c [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-      id = 0 : i64,
-      portID = 2 : i64
-    }],
-    out d: !firrtl.uint<1> sym @d [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-      id = 0 : i64,
-      portID = 3 : i64
-    }]
-  ) attributes {
-    annotations = [{class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"}],
-    defname = "DataTap"
-  }
-
-  firrtl.module private @Foo(
-    out %g: !firrtl.uint<1> sym @g [{
-      circt.nonlocal = @nla_2,
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 2 : i64
-    }]
-  ) {
-    %f = firrtl.wire sym @f {annotations = [{
-      circt.nonlocal = @nla_1,
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 1 : i64
-    }]} : !firrtl.uint<1>
-  }
-
-  firrtl.module @NLAUsedInWiring() {
-    %foo_g = firrtl.instance foo sym @foo @Foo(out g: !firrtl.uint<1>)
-    %bar_g = firrtl.instance bar @Foo(out g: !firrtl.uint<1>)
-    %k = firrtl.wire sym @k {annotations = [{
-      class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-      id = 0 : i64,
-      portID = 3 : i64
-    }]} : !firrtl.uint<1>
-    %dataTap_b, %dataTap_c, %dataTap_d = firrtl.instance dataTap @DataTap(out b: !firrtl.uint<1>, out c: !firrtl.uint<1>, out d: !firrtl.uint<1>)
-  }
-}
-
-// -----
-
-// Check that NLAs not rooted at the top module still produce correct XMRs.
-// See https://github.com/llvm/circt/issues/2767.
-
-firrtl.circuit "Top" {
-  hw.hierpath private @nla_0 [@DUT::@submodule_1, @Submodule::@bar_0]
-  hw.hierpath private @nla [@DUT::@submodule_2, @Submodule::@bar_0]
-  firrtl.module private @Submodule(in %clock: !firrtl.clock, out %out: !firrtl.uint<1>) {
-    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
-    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>
-    %bar_0 = firrtl.reg sym @bar_0 %clock  {annotations = [{circt.nonlocal = @nla, class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 1 : i64, portID = 0 : i64}, {circt.nonlocal = @nla_0, class = "sifive.enterprise.grandcentral.MemTapAnnotation.source", id = 0 : i64, portID = 0 : i64}]} : !firrtl.uint<1>
-    // CHECK:  %bar_0 = firrtl.reg sym @[[bar_0:.+]] %clock  : !firrtl.uint<1>
-    %bar_out_MPORT = firrtl.mem sym @bar Undefined  {depth = 1 : i64, modName = "bar_ext", name = "bar", portNames = ["out_MPORT"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %0 = firrtl.subfield %bar_out_MPORT[addr] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %1 = firrtl.subfield %bar_out_MPORT[en] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %2 = firrtl.subfield %bar_out_MPORT[clk] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    %3 = firrtl.subfield %bar_out_MPORT[data] : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<1>>
-    firrtl.strictconnect %0, %c0_ui1 : !firrtl.uint<1>
-    firrtl.strictconnect %1, %c1_ui1 : !firrtl.uint<1>
-    firrtl.strictconnect %2, %clock : !firrtl.clock
-    firrtl.strictconnect %out, %3 : !firrtl.uint<1>
-  }
-  firrtl.module private @DUT(in %clock: !firrtl.clock, out %out: !firrtl.uint<1>) {
-    %submodule_1_clock, %submodule_1_out = firrtl.instance submodule_1 sym @submodule_1 @Submodule(in clock: !firrtl.clock, out out: !firrtl.uint<1>)
-    firrtl.strictconnect %submodule_1_clock, %clock : !firrtl.clock
-    %submodule_2_clock, %submodule_2_out = firrtl.instance submodule_2 sym @submodule_2 @Submodule(in clock: !firrtl.clock, out out: !firrtl.uint<1>)
-    firrtl.strictconnect %submodule_2_clock, %clock : !firrtl.clock
-    %0 = firrtl.or %submodule_1_out, %submodule_2_out : (!firrtl.uint<1>, !firrtl.uint<1>) -> !firrtl.uint<1>
-    firrtl.strictconnect %out, %0 : !firrtl.uint<1>
-    %mem_tap_MemTap_1_mem_0 = firrtl.instance mem_tap_MemTap_1  @MemTap_1(out mem_0: !firrtl.uint<1>)
-    %mem_tap_MemTap_2_mem_0 = firrtl.instance mem_tap_MemTap_2  @MemTap_2(out mem_0: !firrtl.uint<1>)
-  }
-  firrtl.module @Top(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %out: !firrtl.uint<1>) {
-    %dut_clock, %dut_out = firrtl.instance dut sym @dut @DUT(in clock: !firrtl.clock, out out: !firrtl.uint<1>)
-    firrtl.strictconnect %dut_clock, %clock : !firrtl.clock
-    firrtl.strictconnect %out, %dut_out : !firrtl.uint<1>
-  }
-
-  // CHECK-LABEL: firrtl.module private @MemTap_1_impl_0
-  // CHECK-NEXT{LITERAL}: firrtl.verbatim.expr "{{0}}.{{1}}.{{2}}"
-  // CHECK-SAME: symbols = [@DUT, #hw.innerNameRef<@DUT::@submodule_1>, #hw.innerNameRef<@Submodule::@[[bar_0]]>]
-  firrtl.extmodule private @MemTap_1(out mem_0: !firrtl.uint<1> [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 0 : i64, portID = 0 : i64}]) attributes {defname = "MemTap"}
-  // CHECK-LABEL: firrtl.module private @MemTap_2_impl_0
-  // CHECK-NEXT{LITERAL}: firrtl.verbatim.expr "{{0}}.{{1}}.{{2}}"
-  // CHECK-SAME: symbols = [@DUT, #hw.innerNameRef<@DUT::@submodule_2>, #hw.innerNameRef<@Submodule::@[[bar_0]]>]
-  firrtl.extmodule private @MemTap_2(out mem_0: !firrtl.uint<1> [{class = "sifive.enterprise.grandcentral.MemTapAnnotation.port", id = 1 : i64, portID = 0 : i64}]) attributes {defname = "MemTap"}
-}
-
-// -----
-
-// Check that an empty data tap module and its instantiations is deleted.
-
-// CHECK-LABEL: "Top"
-// CHECK-NOT: firrtl.extmodule {{.+}}@DataTap
-// CHECK-NOT: firrtl.instance DataTap @DataTap()
-firrtl.circuit "Top" {
-  firrtl.extmodule @DataTap() attributes {annotations = [{class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"}]}
-  firrtl.module @DUT() {
-    firrtl.instance DataTap @DataTap()
-  }
-  firrtl.module @Top() {
-    firrtl.instance dut @DUT()
-  }
-}
-
-// -----
-
-// Check that zero-width data taps are no-ops.  These should generate no XMRs.
-//
-firrtl.circuit "Top"  {
-  firrtl.extmodule private @DataTap(
-    out _0: !firrtl.uint<0> [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-        id = 0 : i64,
-        portID = 1 : i64
-      }
-    ],
-    out _1: !firrtl.uint<0> [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-        id = 0 : i64,
-        portID = 2 : i64
-      }
-    ]) attributes {annotations = [
-      {class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"}
-    ]}
-  firrtl.module @Top(
-    out %p: !firrtl.uint<0> [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-        id = 0 : i64,
-        portID = 2 : i64
-      }
-    ]) {
-    %w = firrtl.wire {annotations = [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-        id = 0 : i64,
-        portID = 1 : i64
-      }
-    ]} : !firrtl.uint<0>
-    %tap_0, %tap_1 = firrtl.instance tap @DataTap(
-      out _0: !firrtl.uint<0>,
-      out _1: !firrtl.uint<0>
-    )
-  }
-}
-
-// CHECK-NOT: firrtl.verbatim.expr
-
-// -----
-
-// Check that constants are sunk into XMRs and symbols are not unnecessarily
-// created.
-//
-// CHECK-LABEL: "ConstantSinking"
-firrtl.circuit "ConstantSinking"  {
-  // CHECK:      firrtl.module private @DataTap
-  // CHECK-NEXT:   %[[one:.+]] = firrtl.constant 1
-  // CHECK-NEXT:   firrtl.connect %a, %[[one]]
-  firrtl.extmodule private @DataTap(
-    out a: !firrtl.uint<1> [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.port",
-        id = 0 : i64,
-        portID = 1 : i64
-      }
-    ]) attributes {annotations = [
-      {
-        class = "sifive.enterprise.grandcentral.DataTapsAnnotation.blackbox"
-      }
-    ]}
-  // CHECK: firrtl.module @ConstantSinking
-  firrtl.module @ConstantSinking() {
-    %dataTap_a = firrtl.instance dataTap interesting_name  @DataTap(out a: !firrtl.uint<1>)
-    // CHECK:    %w = firrtl.wire
-    // CHECK-NOT   sym
-    %w = firrtl.wire {annotations = [
-      {
-        class = "sifive.enterprise.grandcentral.ReferenceDataTapKey.source",
-        id = 0 : i64,
-        portID = 1 : i64
-      }
-    ]} : !firrtl.uint<1>
-    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
-    firrtl.strictconnect %w, %c1_ui1 : !firrtl.uint<1>
-  }
-}
diff --git a/test/Dialect/FIRRTL/lowerXMR.mlir b/test/Dialect/FIRRTL/lowerXMR.mlir
index 672118502..c551b9cea 100644
--- a/test/Dialect/FIRRTL/lowerXMR.mlir
+++ b/test/Dialect/FIRRTL/lowerXMR.mlir
@@ -23,7 +23,7 @@ firrtl.circuit "xmr" {
 // Test the correct xmr path is generated
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK:      hw.hierpath @[[path:[a-zA-Z0-9_]+]]
+  // CHECK:      hw.hierpath private @[[path:[a-zA-Z0-9_]+]]
   // CHECK-SAME:   [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod() {
@@ -75,7 +75,7 @@ firrtl.circuit "Top" {
 // Test the correct xmr path to port is generated
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(in %pa: !firrtl.uint<1>, out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod(in %pa: !firrtl.uint<1> sym @[[xmrSym]]) {
     %1 = firrtl.ref.send %pa : !firrtl.uint<1>
@@ -103,11 +103,11 @@ firrtl.circuit "Top" {
 // Test for multiple readers and multiple instances
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK-DAG: hw.hierpath @[[path_0:[a-zA-Z0-9_]+]] [@Foo::@fooXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
-  // CHECK-DAG: hw.hierpath @[[path_1:[a-zA-Z0-9_]+]] [@Bar::@barXMR, @XmrSrcMod::@[[xmrSym]]]
-  // CHECK-DAG: hw.hierpath @[[path_2:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym]]]
-  // CHECK-DAG: hw.hierpath @[[path_3:[a-zA-Z0-9_]+]] [@Top::@foo, @Foo::@fooXMR, @XmrSrcMod::@[[xmrSym]]]
-  // CHECK-DAG: hw.hierpath @[[path_4:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym]]]
+  // CHECK-DAG: hw.hierpath private @[[path_0:[a-zA-Z0-9_]+]] [@Foo::@fooXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK-DAG: hw.hierpath private @[[path_1:[a-zA-Z0-9_]+]] [@Bar::@barXMR, @XmrSrcMod::@[[xmrSym]]]
+  // CHECK-DAG: hw.hierpath private @[[path_2:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym]]]
+  // CHECK-DAG: hw.hierpath private @[[path_3:[a-zA-Z0-9_]+]] [@Top::@foo, @Foo::@fooXMR, @XmrSrcMod::@[[xmrSym]]]
+  // CHECK-DAG: hw.hierpath private @[[path_4:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod() {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
@@ -171,7 +171,7 @@ firrtl.circuit "Top" {
 // Check for downward reference
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod() {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
@@ -210,7 +210,7 @@ firrtl.circuit "Top" {
 // Check for downward reference to port
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(in %pa: !firrtl.uint<1>, out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod(in %pa: !firrtl.uint<1> sym @xmr_sym) {
     %1 = firrtl.ref.send %pa : !firrtl.uint<1>
@@ -245,8 +245,8 @@ firrtl.circuit "Top" {
 // Test for multiple paths and downward reference.
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path_0:[a-zA-Z0-9_]+]] [@Top::@foo, @Foo::@fooXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
-  // CHECK: hw.hierpath @[[path_1:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym]]]
+  // CHECK: hw.hierpath private @[[path_0:[a-zA-Z0-9_]+]] [@Top::@foo, @Foo::@fooXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path_1:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
     %1 = firrtl.ref.send %zero : !firrtl.uint<1>
@@ -280,7 +280,7 @@ firrtl.circuit "Top" {
 // Test for multiple children paths
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
     %1 = firrtl.ref.send %zero : !firrtl.uint<1>
@@ -326,7 +326,7 @@ firrtl.circuit "Top" {
 // Test for multiple children paths
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
     %1 = firrtl.ref.send %zero : !firrtl.uint<1>
@@ -371,7 +371,7 @@ firrtl.circuit "Top" {
 
 // Multiply instantiated Top works, because the reference port does not flow through it.
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Dut::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Dut::@xmr, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     %zero = firrtl.constant 0 : !firrtl.uint<1>
     %1 = firrtl.ref.send %zero : !firrtl.uint<1>
@@ -421,7 +421,7 @@ firrtl.circuit "Top" {
 // -----
 
 firrtl.circuit "Top"  {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr_sym, @DUTModule::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr_sym, @DUTModule::@[[xmrSym:[a-zA-Z0-9_]+]]]
   // CHECK-LABEL: firrtl.module private @DUTModule
   // CHECK-SAME: (in %clock: !firrtl.clock, in %io_addr: !firrtl.uint<3>, in %io_dataIn: !firrtl.uint<8>, in %io_wen: !firrtl.uint<1>, out %io_dataOut: !firrtl.uint<8>)
   firrtl.module private @DUTModule(in %clock: !firrtl.clock, in %io_addr: !firrtl.uint<3>, in %io_dataIn: !firrtl.uint<8>, in %io_wen: !firrtl.uint<1>, out %io_dataOut: !firrtl.uint<8>, out %_gen_memTap: !firrtl.ref<vector<uint<8>, 8>>) attributes {annotations = [{class = "sifive.enterprise.firrtl.MarkDUTAnnotation"}]} {
@@ -505,7 +505,7 @@ firrtl.circuit "Top"  {
 // -----
 
 firrtl.circuit "Top"  {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr_sym, @DUTModule::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@xmr_sym, @DUTModule::@[[xmrSym:[a-zA-Z0-9_]+]]]
   // CHECK-LABEL:  firrtl.module private @DUTModule
   // CHECK-SAME: in %io_wen: !firrtl.uint<1>, out %io_dataOut: !firrtl.uint<8>)
   firrtl.module private @DUTModule(in %clock: !firrtl.clock, in %io_addr: !firrtl.uint<3>, in %io_dataIn: !firrtl.uint<8>, in %io_wen: !firrtl.uint<1>, out %io_dataOut: !firrtl.uint<8>, out %_gen_memTap_0: !firrtl.ref<uint<8>>, out %_gen_memTap_1: !firrtl.ref<uint<8>>) attributes {annotations = [{class = "sifive.enterprise.firrtl.MarkDUTAnnotation"}]} {
@@ -540,7 +540,7 @@ firrtl.circuit "Top"  {
 // Test lowering of internal path into a module
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod() {
     // CHECK-NEXT: }
@@ -570,7 +570,7 @@ firrtl.circuit "Top" {
 // Test lowering of internal path into a module
 // CHECK-LABEL: firrtl.circuit "Top" {
 firrtl.circuit "Top" {
-  // CHECK: hw.hierpath @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
+  // CHECK: hw.hierpath private @[[path:[a-zA-Z0-9_]+]] [@Top::@bar, @Bar::@barXMR, @XmrSrcMod::@[[xmrSym:[a-zA-Z0-9_]+]]]
   firrtl.module @XmrSrcMod(out %_a: !firrtl.ref<uint<1>>) {
     // CHECK: firrtl.module @XmrSrcMod() {
     // CHECK{LITERAL}:  firrtl.verbatim.expr "internal.path" : () -> !firrtl.uint<1> {symbols = [@XmrSrcMod]}
diff --git a/test/Scheduling/modulo-problems.mlir b/test/Scheduling/modulo-problems.mlir
index 615f72d0e..5318131e1 100644
--- a/test/Scheduling/modulo-problems.mlir
+++ b/test/Scheduling/modulo-problems.mlir
@@ -20,7 +20,7 @@ func.func @canis14_fig2() attributes {
 }
 
 // SIMPLEX-LABEL: minII_feasible
-// SIMPLEX-SAME: simplexInitiationInterval = 4
+// SIMPLEX-SAME: simplexInitiationInterval = 3
 func.func @minII_feasible() attributes {
   problemInitiationInterval = 3,
   auxdeps = [ [6,1,5], [5,2,3], [6,7] ],
diff --git a/tools/circt-reduce/Reduction.cpp b/tools/circt-reduce/Reduction.cpp
index 49e89e574..a5856d385 100644
--- a/tools/circt-reduce/Reduction.cpp
+++ b/tools/circt-reduce/Reduction.cpp
@@ -106,7 +106,7 @@ static uint64_t computeTransitiveModuleSize(
 
     auto allInstancesCovered = [&]() {
       return llvm::all_of(
-          moduleOp.getSymbolUses(moduleOp->getParentOfType<ModuleOp>()).value(),
+          *moduleOp.getSymbolUses(moduleOp->getParentOfType<ModuleOp>()),
           [&](auto symbolUse) {
             return std::binary_search(instances.begin(), instances.end(),
                                       symbolUse.getUser());
@@ -128,12 +128,12 @@ static LogicalResult collectInstantiatedModules(
     return failure();
 
   uint64_t opCount = 0;
-  WalkResult result = fmoduleOp.value().walk([&](Operation *op) {
+  WalkResult result = fmoduleOp->walk([&](Operation *op) {
     if (auto instOp = dyn_cast<firrtl::InstanceOp>(op)) {
       auto moduleOp = findInstantiatedModule(instOp, symbols);
       if (!moduleOp) {
         LLVM_DEBUG(llvm::dbgs()
-                   << "- `" << fmoduleOp.value().moduleName()
+                   << "- `" << fmoduleOp->moduleName()
                    << "` recursively instantiated non-FIRRTL module.\n");
         return WalkResult::interrupt();
       }
@@ -150,7 +150,7 @@ static LogicalResult collectInstantiatedModules(
   if (result.wasInterrupted())
     return failure();
 
-  modules.push_back(std::make_pair(fmoduleOp.value(), opCount));
+  modules.push_back(std::make_pair(*fmoduleOp, opCount));
 
   return success();
 }
diff --git a/tools/firtool/firtool.cpp b/tools/firtool/firtool.cpp
index b910aba8b..a1c4735fe 100644
--- a/tools/firtool/firtool.cpp
+++ b/tools/firtool/firtool.cpp
@@ -608,7 +608,7 @@ processBuffer(MLIRContext &context, TimingScope &ts, llvm::SourceMgr &sourceMgr,
     if (failed(pm.run(module.get())))
       return failure();
     auto outputTimer = ts.nest("Print .mlir output");
-    printOp(*module, outputFile.value()->os());
+    printOp(*module, (*outputFile)->os());
     return success();
   }
 
@@ -727,11 +727,11 @@ processBuffer(MLIRContext &context, TimingScope &ts, llvm::SourceMgr &sourceMgr,
 
   // Run passes to resolve Grand Central features.  This should run before
   // BlackBoxReader because Grand Central needs to inform BlackBoxReader where
-  // certain black boxes should be placed.
+  // certain black boxes should be placed.  Note: all Grand Central Taps related
+  // collateral is resolved entirely by LowerAnnotations.
   if (!disableGrandCentral) {
     auto &circuitPM = pm.nest<firrtl::CircuitOp>();
     circuitPM.addPass(firrtl::createGrandCentralPass());
-    circuitPM.addPass(firrtl::createGrandCentralTapsPass());
     circuitPM.addPass(
         firrtl::createGrandCentralSignalMappingsPass(outputFilename));
   }
@@ -875,7 +875,7 @@ processBuffer(MLIRContext &context, TimingScope &ts, llvm::SourceMgr &sourceMgr,
     default:
       llvm_unreachable("can't reach this");
     case OutputVerilog:
-      exportPm.addPass(createExportVerilogPass(outputFile.value()->os()));
+      exportPm.addPass(createExportVerilogPass((*outputFile)->os()));
       break;
     case OutputSplitVerilog:
       exportPm.addPass(createExportSplitVerilogPass(outputFilename));
@@ -898,7 +898,7 @@ processBuffer(MLIRContext &context, TimingScope &ts, llvm::SourceMgr &sourceMgr,
   if (outputFormat == OutputIRFir || outputFormat == OutputIRHW ||
       outputFormat == OutputIRSV || outputFormat == OutputIRVerilog) {
     auto outputTimer = ts.nest("Print .mlir output");
-    printOp(*module, outputFile.value()->os());
+    printOp(*module, (*outputFile)->os());
   }
 
   // If requested, print the final MLIR into mlirOutFile.
@@ -1008,7 +1008,7 @@ static LogicalResult executeFirtool(MLIRContext &context) {
   if (outputFormat != OutputSplitVerilog) {
     // Create an output file.
     outputFile.emplace(openOutputFile(outputFilename, &errorMessage));
-    if (!outputFile.value()) {
+    if (!(*outputFile)) {
       llvm::errs() << errorMessage << "\n";
       return failure();
     }
@@ -1037,7 +1037,7 @@ static LogicalResult executeFirtool(MLIRContext &context) {
 
   // If the result succeeded and we're emitting a file, close it.
   if (outputFile.has_value())
-    outputFile.value()->keep();
+    (*outputFile)->keep();
 
   return success();
 }
diff --git a/tools/hlstool/hlstool.cpp b/tools/hlstool/hlstool.cpp
index dd0f9b759..974054f31 100644
--- a/tools/hlstool/hlstool.cpp
+++ b/tools/hlstool/hlstool.cpp
@@ -378,7 +378,7 @@ doHLSFlowDynamic(PassManager &pm, ModuleOp module,
   if (outputFormat == OutputVerilog) {
     if (loweringOptions.getNumOccurrences())
       loweringOptions.setAsAttribute(module);
-    pm.addPass(createExportVerilogPass(outputFile.value()->os()));
+    pm.addPass(createExportVerilogPass((*outputFile)->os()));
   }
 
   // Go execute!
@@ -386,7 +386,7 @@ doHLSFlowDynamic(PassManager &pm, ModuleOp module,
     return failure();
 
   if (outputFormat == OutputIR)
-    module->print(outputFile.value()->os());
+    module->print((*outputFile)->os());
 
   return success();
 }
@@ -491,7 +491,7 @@ static LogicalResult executeHlstool(MLIRContext &context) {
 
   Optional<std::unique_ptr<llvm::ToolOutputFile>> outputFile;
   outputFile.emplace(openOutputFile(outputFilename, &errorMessage));
-  if (!outputFile.value()) {
+  if (!*outputFile) {
     llvm::errs() << errorMessage << "\n";
     return failure();
   }
@@ -502,7 +502,7 @@ static LogicalResult executeHlstool(MLIRContext &context) {
 
   // If the result succeeded and we're emitting a file, close it.
   if (outputFile.has_value())
-    outputFile.value()->keep();
+    (*outputFile)->keep();
 
   return success();
 }
diff --git a/tools/llhd-sim/CMakeLists.txt b/tools/llhd-sim/CMakeLists.txt
index 0029fafa5..83454da8a 100644
--- a/tools/llhd-sim/CMakeLists.txt
+++ b/tools/llhd-sim/CMakeLists.txt
@@ -8,7 +8,7 @@ set(LIBS
 
 # llhd-sim fails to link on Windows with MSVC.
 IF(CIRCT_LLHD_SIM_ENABLED)
-  add_llvm_executable(llhd-sim
+  add_llvm_tool(llhd-sim
     llhd-sim.cpp)
   
   llvm_update_compile_flags(llhd-sim)
